<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>cloudflare创建自己的短链生成网站</title>
    <url>/2023/08/18/%E4%BD%BF%E7%94%A8cloudflare%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E7%9F%AD%E9%93%BE%E7%94%9F%E6%88%90%E7%BD%91%E7%AB%99/</url>
    <content><![CDATA[<h3 id="本教程需要使用的网站或工具："><a href="#本教程需要使用的网站或工具：" class="headerlink" title="本教程需要使用的网站或工具："></a>本教程需要使用的网站或工具：</h3><ol>
<li><a href="https://www.cloudflare.com/">https://www.cloudflare.com/</a></li>
<li>一个域名（需要解析到cloudflare上面）</li>
<li>科学上网</li>
</ol>
<h3 id="教程："><a href="#教程：" class="headerlink" title="教程："></a>教程：</h3><ol>
<li><p>登录cloudflare</p>
</li>
<li><p>点击<code>Workers 和 Pages</code></p>
</li>
<li><p>点击<strong>KV</strong></p>
<img src="https://github.com/ninuan/images/raw/main//images/image-20230720232556634.png" alt="image-20230720232556634" style="zoom:50%;" />
</li>
<li><p>点击创建命名空间，点击添加</p>
<img src="https://github.com/ninuan/images/raw/main//images/image-20230720232658914.png" alt="image-20230720232658914" style="zoom:50%;" />
</li>
<li><p>完成之后点击查看，输入密钥和值（随意，或者可以按照我的填写），点击添加条目</p>
<img src="https://github.com/ninuan/images/raw/main//images/image-20230720232900640.png" alt="image-20230720232900640" style="zoom:50%;" />
</li>
<li><p>点击概述，创建应用程序</p>
<img src="https://github.com/ninuan/images/raw/main//images/image-20230720233042717.png" alt="image-20230720233042717" style="zoom:50%;" />
</li>
<li><p>点击创建Worker，名称随意，点击部署</p>
<img src="https://github.com/ninuan/images/raw/main//images/image-20230720233249511.png" alt="image-20230720233249511" style="zoom:50%;" />
</li>
<li><p>点击编辑代码，进入之后把原先的代码删完，复制这个代码<code>https://github.com/a624587332/Url-Shorten-Worker/blob/main/index.js</code>,粘贴，修改178行成baidu.com等国内网站或者你自己的博客地址也行，然后点击保存并部署</p>
<img src="https://github.com/ninuan/images/raw/main//images/image-20230720233559571.png" alt="image-20230720233559571" style="zoom:50%;" />
</li>
<li><p>回到workers空间，点击设置，点击变量</p>
<img src="https://github.com/ninuan/images/raw/main//images/image-20230720233741484.png" alt="image-20230720233741484" style="zoom:50%;" />
</li>
<li><p>下滑找到KV命名空间绑定，名称填<code>LINKS</code></p>
<img src="https://github.com/ninuan/images/raw/main//images/image-20230720233919422.png" alt="image-20230720233919422" style="zoom:50%;" />
</li>
<li><p>现在即可通过访问提供的网址进行访问<code>https://....workers.dev/dlj</code>，<code>dlj</code>就是你在第五部中添加的值，因为dev域名污染严重，有时候会进不去，我们可以绑定自己的域名，点击查看（如果没有域名，到这一步即可以使用）</p>
<img src="https://github.com/ninuan/images/raw/main//images/image-20230720234442039.png" alt="image-20230720234442039" style="zoom:50%;" />
</li>
<li><p>点击添加自定义域（域名需要在cloudflare存在解析，然后自己在域名前面添加二级域名即可）</p>
<img src="https://github.com/ninuan/images/raw/main//images/image-20230720234555680.png" alt="image-20230720234555680" style="zoom: 50%;" />
</li>
<li><p>通过你添加的域名加上第五步中你设置的值即可访问</p>
<img src="https://github.com/ninuan/images/raw/main//images/image-20230720234900048.png" alt="image-20230720234900048" style="zoom:50%;" /></li>
</ol>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>cloudflare</tag>
      </tags>
  </entry>
  <entry>
    <title>自建测速节点，解决V2rayN测速为0的问题</title>
    <url>/2023/08/18/%E8%87%AA%E5%BB%BA%E6%B5%8B%E9%80%9F%E8%8A%82%E7%82%B9%EF%BC%8C%E8%A7%A3%E5%86%B3V2rayN%E6%B5%8B%E9%80%9F%E4%B8%BA0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="本教程需要使用的网站或工具："><a href="#本教程需要使用的网站或工具：" class="headerlink" title="本教程需要使用的网站或工具："></a>本教程需要使用的网站或工具：</h3><ol>
<li><a href="https://www.cloudflare.com/">https://www.cloudflare.com/</a></li>
<li>一个域名（需要解析到cloudflare上面）</li>
<li>科学上网</li>
</ol>
<h3 id="如果不想花费力气，直接下载：测速"><a href="#如果不想花费力气，直接下载：测速" class="headerlink" title="如果不想花费力气，直接下载：测速"></a>如果不想花费力气，直接下载：<a href="https://short.ninuan.link/yxip">测速</a></h3><h3 id="教程："><a href="#教程：" class="headerlink" title="教程："></a>教程：</h3><ol>
<li><p>登录cloudflare，点击<code>Workers和Pages</code>，创建应用程序</p>
<img src="https://github.com/ninuan/images/raw/main//images/image-20230721144833007.png" alt="image-20230721144833007" style="zoom:50%;" />
</li>
<li><p>点击创建Worker，名称随意（但是不能跟已有的重复），点击部署</p>
<img src="https://github.com/ninuan/images/raw/main//images/image-20230721145006155.png" alt="image-20230721145006155" style="zoom:50%;" />
</li>
<li><p>点击编辑代码，进入之后把原先的代码删完，复制代码，粘贴，然后点击<strong>保存并部署</strong>（如果还是不能使用，替换第四行的链接，在<a href="https://github.com/XIU2/CloudflareSpeedTest/issues/168">https://github.com/XIU2/CloudflareSpeedTest/issues/168</a> 里面找到能用的链接就行）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">addEventListener</span>(<span class="string">&quot;fetch&quot;</span>, <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> url = <span class="keyword">new</span> <span class="title function_">URL</span>(event.<span class="property">request</span>.<span class="property">url</span>);</span><br><span class="line">  <span class="keyword">if</span> (url.<span class="property">pathname</span> == <span class="string">&quot;/&quot;</span> &amp;&amp; url.<span class="property">search</span> == <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">    url.<span class="property">href</span>=<span class="string">&quot;https://cloudflarest.itkyou.cf/100mb.zip&quot;</span></span><br><span class="line">    <span class="keyword">let</span> request = <span class="keyword">new</span> <span class="title class_">Request</span>(url, event.<span class="property">request</span>);</span><br><span class="line">    event.<span class="title function_">respondWith</span>(<span class="title function_">fetch</span>(request));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>回到Workers空间，找到<code>Custom Domains</code>，点击查看</p>
<img src="https://github.com/ninuan/images/raw/main//images/image-20230721145322954.png" alt="image-20230721145322954" style="zoom:50%;" />
</li>
<li><p>点击添加自定义域（域名需要在cloudflare存在解析，然后自己在域名前面添加二级域名即可）</p>
<img src="https://github.com/ninuan/images/raw/main//images/image-20230721145418347.png" alt="image-20230721145418347" style="zoom:50%;" />
</li>
<li><p>现在将添加的自定义域名放到V2rayN里面即可（最好使用最新版本）</p>
<img src="https://github.com/ninuan/images/raw/main//images/image-20230721145535312.png" alt="image-20230721145535312" style="zoom:50%;" /></li>
</ol>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>cloudflare</tag>
      </tags>
  </entry>
  <entry>
    <title>节点测速的高速方法</title>
    <url>/2023/08/18/%E8%8A%82%E7%82%B9%E6%B5%8B%E9%80%9F%E7%9A%84%E9%AB%98%E9%80%9F%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="高速优选节点快速的IP"><a href="#高速优选节点快速的IP" class="headerlink" title="高速优选节点快速的IP"></a>高速优选节点快速的IP</h2><ol>
<li><p>根据规则找到反代cloudflare的ip，网址<a href="https://fofa.info/">https://fofa.info</a></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 规则--根据自己想要的节点自己选择</span></span><br><span class="line">国内反代IP：server==&quot;cloudflare&quot; &amp;&amp; port==&quot;80&quot; &amp;&amp; header=&quot;Forbidden&quot; &amp;&amp; country==&quot;CN&quot;</span><br><span class="line">剔除CF：asn!=&quot;13335&quot; &amp;&amp; asn!=&quot;209242&quot;</span><br><span class="line">阿里云：server==&quot;cloudflare&quot; &amp;&amp; asn==&quot;45102&quot;</span><br><span class="line">甲骨文韩国：server==&quot;cloudflare&quot; &amp;&amp; asn==&quot;31898&quot; &amp;&amp; country==&quot;KR&quot;</span><br><span class="line">搬瓦工：server==&quot;cloudflare&quot; &amp;&amp; asn==&quot;25820&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>网站注册</p>
<p>临时邮箱：<a href="http://24mail.chacuo.net/">http://24mail.chacuo.net</a><br>（一个邮箱额度有限，可以用虚拟邮箱）</p>
</li>
<li><p>搜索完成后，点击下载</p>
<img src="https://github.com/ninuan/images/raw/main//images/image-20230723204214913.png" alt="image-20230723204214913" style="zoom:50%;" />
</li>
<li><p>下载到本地后，打开，找到对应的ip复制</p>
<img src="https://github.com/ninuan/images/raw/main//images/image-20230723204248143.png" alt="image-20230723204248143" style="zoom:50%;" />
</li>
<li><p>打开网址<a href="https://bulianglin.com/archives/cdn.html">https://bulianglin.com/archives/cdn.html</a> </p>
<p>原始节点需要用自己的节点分享出来，地址的话填写自己的伪装域名</p>
<img src="https://github.com/ninuan/images/raw/main//images/image-20230723210812062.png" alt="image-20230723210812062" style="zoom:50%;" />

<img src="https://github.com/ninuan/images/raw/main//images/image-20230723204500044.png" alt="image-20230723204500044" style="zoom:50%;" />
</li>
<li><p>下载测速工具<a href="https://short.ninuan.link/node">https://short.ninuan.link/node</a> ,解压后打开exe文件</p>
<img src="https://github.com/ninuan/images/raw/main//images/image-20230723210248913.png" alt="image-20230723210248913" style="zoom:50%;" />

<p>导入进去之后，<code>Ctrl + A</code>全选，右键测试延迟和速度（延迟内核和下载内核vless都选Xray，vmess内核选clash、Xray），测试完成之后复制节点导入到科学上网工具就行</p>
</li>
</ol>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>vpn</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown配合图床上传图片到Github</title>
    <url>/2023/08/18/Markdown%E9%85%8D%E5%90%88%E5%9B%BE%E5%BA%8A%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E5%88%B0Github/</url>
    <content><![CDATA[<p>Markdown配合图床上传图片到Github</p>
<ol>
<li><p>获取token</p>
<ol>
<li><p>打开github，进入设置，找到<code>Developer settings</code></p>
</li>
<li><p>点击<code>Personal access tokens</code>，选择<code>Tokens(classic)</code></p>
</li>
<li><p>选择<code>Generate new token（classic）</code></p>
<img src="https://github.com/ninuan/images/raw/main//images/image-20230807222401180.png" alt="image-20230807222401180" style="zoom:50%;" />
</li>
<li><p>时限改为<code>No expiration</code>，选择<code>repo</code>，点击生成，保存生成的token后续使用</p>
<img src="https://github.com/ninuan/images/raw/main//images/image-20230807222619122.png" alt="image-20230807222619122" style="zoom:50%;" /></li>
</ol>
</li>
<li><p>进入typora，点击文件，偏好设置，选择PicGo-Core(command line)，图像中的其他选项按照下图所示进行选择</p>
</li>
</ol>
<img src="https://github.com/ninuan/images/raw/main//images/image-20230807221541947.png" alt="image-20230807221541947" style="zoom:50%;" />

<ol start="3">
<li>点击下载或更新，弹出的框选择下载</li>
</ol>
<img src="https://github.com/ninuan/images/raw/main//images/image-20230807221703975.png" alt="image-20230807221703975" style="zoom:50%;" />

<ol start="4">
<li><p>下载成功后，点击打开配置文件，填入下面的代码</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;picBed&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;current&quot;</span><span class="punctuation">:</span> <span class="string">&quot;github&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;github&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;repo&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ninuan/images&quot;</span><span class="punctuation">,</span>  <span class="comment">//填写自己的仓库名字</span></span><br><span class="line">      <span class="attr">&quot;branch&quot;</span><span class="punctuation">:</span> <span class="string">&quot;main&quot;</span><span class="punctuation">,</span> <span class="comment">//自己的分支，main或者master</span></span><br><span class="line">      <span class="attr">&quot;token&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span> <span class="comment">// 填写第一步获得的token </span></span><br><span class="line">      <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;images/&quot;</span><span class="punctuation">,</span>  <span class="comment">// 仓库中设置的文件名，可以设置，也可以不设置</span></span><br><span class="line">      <span class="attr">&quot;customUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://github.com/ninuan/images/raw/main/&quot;</span>  <span class="comment">// 这个位置按照对应的设置来填写网址，可以打开一个上传后的图片，将网址copy下来，eg.  https://github.com/ninuan/images/blob/main/images/202301051712715.png，对应的位置进行修改，raw一定要修改，否则可以上传但无法加载</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;uploader&quot;</span><span class="punctuation">:</span> <span class="string">&quot;github&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;transformer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;path&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;picgoPlugins&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;picgo-plugin-github-plus&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>点击<code>图片上传选项</code>，提示成功即代表创建成功（后续验证的时候如果出现上传失败，如果之前验证过，因为验证时候上传的图片名称是一样的，可以去仓库把图片删除一下即可，如果是自己上传的图片则没有影响，因为是按照当时的时间自动命的名字）</p>
<img src="https://github.com/ninuan/images/raw/main//images/image-20230807223357215.png" alt="image-20230807223357215" style="zoom:50%;" /></li>
</ol>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Typora</tag>
      </tags>
  </entry>
  <entry>
    <title>vpn搭建教程</title>
    <url>/2023/08/18/VPN%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="VPN搭建教程"><a href="#VPN搭建教程" class="headerlink" title="VPN搭建教程"></a>VPN搭建教程</h1><p>DNS书写：</p>
<ol>
<li><p>安装trojan</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">sudo bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/trojan-gfw/trojan-quickstart/master/trojan-quickstart.sh)&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装nginx搭建https伪装</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">sudo yum update //更新软件包</span><br><span class="line"></span><br><span class="line">//安装nginx</span><br><span class="line">sudo yum install epel-release</span><br><span class="line">sudo yum install nginx</span><br><span class="line"></span><br><span class="line">//启动nginx</span><br><span class="line">systemctl enable nginx; systemctl start nginx</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">默认情况下，Nginx 会监听 80 端口，您可以通过在浏览器中输入服务器的 IP 地址或域名来验证 Nginx 是否安装成功。如果您能够看到 Nginx 的欢迎页面，则表示安装成功。如果未能成功启动 Nginx，请检查 Nginx 的配置文件是否正确，并检查是否有其它服务占用了 80 端口。</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">// nginx页面地址在/usr/share/nginx/html  修改下面的nginx即可搭建成功界面</span><br></pre></td></tr></table></figure>
</li>
<li><p>证书申请</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">//安装certbot</span><br><span class="line">sudo yum install certbot</span><br><span class="line"></span><br><span class="line">// 申请证书</span><br><span class="line">sudo certbot certonly --webroot -w /path/to/your/application/root --domain example.com --email your-email@example.com</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">/path/to/your/application/root 填写自己前端网页地址，例如本实例即为/usr/share/nginx/html</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>4.完善</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//放前端页面</span><br><span class="line">具体位置在nginx.conf里面可以直接找。</span><br><span class="line">//改nginx配置</span><br><span class="line">直接复制nginx.conf替换原来的。</span><br><span class="line">VPS的nginx.conf位置：/etc/nginx/nginx.conf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//改trojan配置：</span><br><span class="line">将config.json文件复制替换原来的：</span><br><span class="line">Trojan的config.json位置:/usr/local/etc/trojan/config.json</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//设置重启和开机自启动，这个直接问chatgpt</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bbr加速安装</span><br><span class="line">//先安装wget</span><br><span class="line">yum install wget</span><br><span class="line"></span><br><span class="line">//安装bbr</span><br><span class="line">wget -N --no-check-certificate &quot;https://gist.github.com/zeruns/a0ec603f20d1b86de6a774a8ba27588f/raw/4f9957ae23f5efb2bb7c57a198ae2cffebfb1c56/tcp.sh&quot; &amp;&amp; chmod +x tcp.sh &amp;&amp; ./tcp.sh</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>vpn</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机类试题</title>
    <url>/2023/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%A2%98%E7%9B%AE/</url>
    <content><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h3 id="头指针和头节点的区别？"><a href="#头指针和头节点的区别？" class="headerlink" title="头指针和头节点的区别？"></a>头指针和头节点的区别？</h3><p>以单链表为例，头指针就是指向链表第一个结点的指针，链表的第一个结点的地址可以通过链表的头指针找到，对单链表中任一元素的访问必须首先根据头指针找到第一个结点。</p>
<p>而头结点是一个附加结点，头结点的data域可以不存储任何信息，也可以存放特殊标志或表长，只要表存在就必须至少有一个头结点。头结点的存在可以优化单链表的增删操作，使得对于空表或者在非空表第一个结点之前插入不用作为特殊情况专门处理，而是使用通用方法。</p>
<h3 id="有一个循环队列Q，里面的编号是0到n-1，头尾指针分别是f，p，现在求Q中元素的个数？"><a href="#有一个循环队列Q，里面的编号是0到n-1，头尾指针分别是f，p，现在求Q中元素的个数？" class="headerlink" title="有一个循环队列Q，里面的编号是0到n-1，头尾指针分别是f，p，现在求Q中元素的个数？"></a>有一个循环队列Q，里面的编号是0到n-1，头尾指针分别是f，p，现在求Q中元素的个数？</h3><p><code>(p-f+n) % n</code></p>
<h3 id="循环队列如何判断是空还是满？"><a href="#循环队列如何判断是空还是满？" class="headerlink" title="循环队列如何判断是空还是满？"></a>循环队列如何判断是空还是满？</h3><p>队空：<code>front == rear</code>  队满：<code>front == (rear + 1) % m</code> </p>
<h3 id="哈希表的概念、构造方法、哈希有几种类型？哈希冲突的解决办法？"><a href="#哈希表的概念、构造方法、哈希有几种类型？哈希冲突的解决办法？" class="headerlink" title="哈希表的概念、构造方法、哈希有几种类型？哈希冲突的解决办法？"></a>哈希表的概念、构造方法、哈希有几种类型？哈希冲突的解决办法？</h3><ol>
<li><p>概念:哈希表通过哈希函数将键映射到表中一个位置来操作数据,以巧妙地将查找和插入的时间复杂度降低到O(1)</p>
</li>
<li><p>构造方法: 直接地址法; 数字分析法; 平方取中法; 随机数法; </p>
</li>
<li><p>哈希冲突的解决方法: </p>
<ol>
<li><p>开放地址法:线性探测、二次探测、伪随机探测等。</p>
</li>
<li><p>再哈希法:用其他哈希函数重新计算。</p>
</li>
<li><p>链地址法:将冲突的元素链起来,链接到同一个位置。</p>
</li>
<li><p>建立公共溢出区:将冲突元素放在其他位置。</p>
</li>
</ol>
</li>
</ol>
<h3 id="判断链表是否有环"><a href="#判断链表是否有环" class="headerlink" title="判断链表是否有环?"></a>判断链表是否有环?</h3><p>快慢指针: 从头开始设置两个指针，快指针每次走2步，慢指针每次走1步，如果快指针先碰到尾，则无环，否则两个指针之后一定会重合，则有环。</p>
<h3 id="平衡二叉树、二叉排序树、完全二叉树、二叉搜索树的区别及如何构造"><a href="#平衡二叉树、二叉排序树、完全二叉树、二叉搜索树的区别及如何构造" class="headerlink" title="平衡二叉树、二叉排序树、完全二叉树、二叉搜索树的区别及如何构造?"></a>平衡二叉树、二叉排序树、完全二叉树、二叉搜索树的区别及如何构造?</h3><ol>
<li><p>完全二叉树的每一个节点都与高度为k的满二叉树的1-n编号一一对应。</p>
</li>
<li><p>二叉搜索树和二叉排序树是一个东西。</p>
<ol>
<li><p>二叉排序树每一个节点都是用于排序的关键码，左子树所有节点关键码都小于根节点的关键码，右子树的所有关键码都大于根节点的关键码，其中，左右子树都是二叉树。对一棵二叉排序树进行中序遍历就可以得到关键码从小到大的排列。</p>
</li>
<li><p>二叉搜索树的构造方法主要执行插入操作，进行插入之前必须先检查是否该节点的关键码已经在树中存在，也就是要先查找，假如查找成功，不执行任何操作，假如搜索不成功，就在搜索停止的地方添加新元素。</p>
</li>
</ol>
</li>
<li><p>平衡二叉树是一种二叉搜索树，它的左右子树高度差的绝对值不超过1。构造一棵平衡二叉树仍然是通过插入节点的方式，每插入一个结点，都应该检查平衡因子，并通过旋转操作使之平衡化。</p>
</li>
</ol>
<h3 id="B树是什么-在数据库中有什么应用？（B数和B-树的区别）"><a href="#B树是什么-在数据库中有什么应用？（B数和B-树的区别）" class="headerlink" title="B树是什么?在数据库中有什么应用？（B数和B+树的区别）?"></a>B树是什么?在数据库中有什么应用？（B数和B+树的区别）?</h3><p>B树的一个结点可以装多个值，读取时，是把整个结点读到内存，然后在内存中，对结点的值进行处理，在内存中处理速度肯定比磁盘快。所以只要树的高度低，IO少，就能够提升查询效率，这是B树的好处之一。</p>
<p>B树的<strong>缺点</strong>是：不利于范围查找(区间查找)，如果要找 0~100的索引值，那么B树需要多次从根结点开始逐个查找。</p>
<p>B+树和B树最大的不同是：B+树内部有两种结点，一种是索引结点，一种是叶子结点。B+树的索引结点并不会保存记录，只用于索引，<strong>所有的数据都保存在B+树的叶子结点</strong>中。而<strong>B树则是所有结点都会保存数据</strong>。</p>
<p><strong>B+树的叶子结点都会被连成一条链表</strong>。叶子本身按索引值的大小从小到大进行排序。即这条链表是 从小到大的。因此可以直接通过遍历链表实现范围查找。</p>
<h3 id="红黑树原理是什么？建立过程？"><a href="#红黑树原理是什么？建立过程？" class="headerlink" title="红黑树原理是什么？建立过程？"></a>红黑树原理是什么？建立过程？</h3><p>​	红黑树（Red-Black Tree）是一种自平衡的二叉搜索树，它在插入和删除操作后通过一系列的旋转和颜色调整来保持树的平衡，从而保证了树的高度始终在一个相对较小的范围内，维持了搜索、插入和删除操作的平均时间复杂度为 O(log n)。</p>
<p>​	红黑树具有以下特性：</p>
<ol>
<li><strong>节点颜色：</strong> 每个节点都被赋予红色或黑色。</li>
<li><strong>根节点：</strong> 根节点是黑色的。</li>
<li><strong>叶子节点（空节点）：</strong> 所有叶子节点都是黑色的。</li>
<li><strong>红色节点的子节点：</strong> 红色节点的子节点必须是黑色的，这确保了没有两个相邻的红色节点。</li>
<li><strong>从任意节点到其每个叶子的简单路径都包含相同数目的黑色节点：</strong> 这个性质保证了树的平衡性，即从根到叶子的最长路径不会超过最短路径的两倍。</li>
</ol>
<p>​	红黑树的建立过程涉及插入和调整。以下是插入新节点时红黑树的建立过程：</p>
<ol>
<li><strong>插入节点：</strong> 将新节点插入到红黑树中，初始状态为红色。</li>
<li><strong>颜色调整：</strong> 检查插入节点的父节点和叔叔节点的颜色情况，进行以下几种情况的调整：<ul>
<li>如果父节点是黑色，无需进一步调整，树仍然满足红黑树性质。</li>
<li>如果父节点是红色，而叔叔节点也是红色，将父节点和叔叔节点变为黑色，将祖父节点变为红色，然后以祖父节点为当前节点进行递归调整，以保持红黑树性质。</li>
<li>如果父节点是红色，而叔叔节点是黑色或缺失，需要通过旋转来进行调整。</li>
</ul>
</li>
<li><strong>旋转操作：</strong> 旋转操作包括左旋和右旋，以恢复树的平衡性。旋转可以分为以下四种情况，分别对应着插入节点的父节点和祖父节点的位置关系以及插入节点的方向：<ul>
<li>LL旋转</li>
<li>RR旋转</li>
<li>LR旋转</li>
<li>RL旋转</li>
</ul>
</li>
</ol>
<p>​	通过递归调整和旋转操作，插入新节点后的红黑树会保持平衡性和红黑树性质。</p>
<h3 id="插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等排序算法的基本思想是什么？时间复杂度？是否稳定？给一个例子，问冒泡和快速排序在最坏的情况下比较几次？（排序必考）"><a href="#插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等排序算法的基本思想是什么？时间复杂度？是否稳定？给一个例子，问冒泡和快速排序在最坏的情况下比较几次？（排序必考）" class="headerlink" title="插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等排序算法的基本思想是什么？时间复杂度？是否稳定？给一个例子，问冒泡和快速排序在最坏的情况下比较几次？（排序必考）"></a>插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等排序算法的基本思想是什么？时间复杂度？是否稳定？给一个例子，问冒泡和快速排序在最坏的情况下比较几次？（排序必考）</h3><table>
<thead>
<tr>
<th>排序方法</th>
<th>时间复杂度（平均）</th>
<th>时间复杂度（最坏）</th>
<th>时间复杂度（最好）</th>
<th>空间复杂度</th>
<th>确定性</th>
</tr>
</thead>
<tbody><tr>
<td>插入排序</td>
<td>O(n^2^)</td>
<td>O(n^2^)</td>
<td>O(n)</td>
<td>O(1)</td>
<td>稳定</td>
</tr>
<tr>
<td>希尔排序</td>
<td>O(n^1.3^)</td>
<td>O(n^2^)</td>
<td>O(n)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td>选择排序</td>
<td>O(n^2^)</td>
<td>O(n^2^)</td>
<td>O(n^2^)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td>堆排序</td>
<td>O(nlog<del>n</del>n)</td>
<td>O(nlog<del>2</del>n)</td>
<td>O(nlog<del>2</del>n)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td>冒泡排序</td>
<td>O(n^2^)</td>
<td>O(n^2^)</td>
<td>O(n)</td>
<td>O(1)</td>
<td>稳定</td>
</tr>
<tr>
<td>快速排序</td>
<td>O(nlog<del>n</del>n)</td>
<td>O(n^2^)</td>
<td>O(nlog<del>n</del>n)</td>
<td>O(nlog<del>n</del>n)</td>
<td>不稳定</td>
</tr>
<tr>
<td>归并排序</td>
<td>O(nlog<del>n</del>n)</td>
<td>O(nlog<del>n</del>n)</td>
<td>O(nlog<del>n</del>n)</td>
<td>O(n)</td>
<td>稳定</td>
</tr>
<tr>
<td>桶排序</td>
<td>O(n+k)</td>
<td>O(n^2^)</td>
<td>O(n)</td>
<td>O(n+k)</td>
<td>稳定</td>
</tr>
<tr>
<td>基数排序</td>
<td>O(n*k)</td>
<td>O(n*k)</td>
<td>O(n*k)</td>
<td>O(n+k)</td>
<td>稳定</td>
</tr>
</tbody></table>
<h3 id="最小生成树和最短路径用什么算法来实现？（迪杰斯特拉、弗洛依德、普利姆、克鲁斯卡尔）算法的基本思想是什么？算法的时间复杂度？如何进行优化？"><a href="#最小生成树和最短路径用什么算法来实现？（迪杰斯特拉、弗洛依德、普利姆、克鲁斯卡尔）算法的基本思想是什么？算法的时间复杂度？如何进行优化？" class="headerlink" title="最小生成树和最短路径用什么算法来实现？（迪杰斯特拉、弗洛依德、普利姆、克鲁斯卡尔）算法的基本思想是什么？算法的时间复杂度？如何进行优化？"></a>最小生成树和最短路径用什么算法来实现？（迪杰斯特拉、弗洛依德、普利姆、克鲁斯卡尔）算法的基本思想是什么？算法的时间复杂度？如何进行优化？</h3><ol>
<li><p>最小生成树：普利姆，克鲁斯卡尔</p>
<p>最短路径：迪杰斯特拉（$O(n^2)$），弗洛伊德（$O(n^3)$）（单源负权边时是弗洛伊德算法）</p>
</li>
<li><p>算法的基本思想：</p>
<p>迪杰斯特拉，普利姆，克鲁斯卡尔都是贪心的思想</p>
<p>弗洛伊德是动态规划的思想</p>
</li>
<li><p>堆优化的迪杰斯特拉，克鲁斯卡尔，普利姆均为$O(nlogn)$</p>
</li>
</ol>
<h3 id="介绍一下字符串匹配算法：朴素的匹配算法和KMP算法。（如何实现要会用语言描述）"><a href="#介绍一下字符串匹配算法：朴素的匹配算法和KMP算法。（如何实现要会用语言描述）" class="headerlink" title="介绍一下字符串匹配算法：朴素的匹配算法和KMP算法。（如何实现要会用语言描述）"></a>介绍一下字符串匹配算法：朴素的匹配算法和KMP算法。（如何实现要会用语言描述）</h3><p>​	<strong>1. 朴素的匹配算法：</strong> 朴素的匹配算法也称为暴力匹配算法，它从文本串的每个位置开始，尝试将模式串与文本串的对应字符逐个比较，如果发现不匹配的字符，则将模式串向右移动一个位置，继续比较。这个过程会持续直到找到匹配或者文本串中没有足够的字符供比较。</p>
<p>​	<strong>实现步骤：</strong></p>
<ol>
<li>从文本串的第一个字符开始，遍历到文本串的倒数第 len(模式串) 个字符。</li>
<li>对于每个位置，将模式串与文本串当前位置开始的子串逐个字符比较，直到发现不匹配的字符或者完全匹配为止。</li>
<li>如果完全匹配，则找到了一个匹配的位置；如果不匹配，则将模式串向右移动一个位置，继续比较下一个子串。</li>
</ol>
<p>​	<strong>2. KMP算法：</strong> KMP算法通过利用模式串的部分匹配表（也称为失效函数或跳转表）来避免在文本串中不必要的比较，从而提高了匹配的效率。它在模式串与文本串匹配的过程中，根据已经匹配的字符，选择跳过一些比较，直接将模式串向右移动到正确的位置。</p>
<p>​	<strong>实现步骤：</strong></p>
<ol>
<li>构建模式串的部分匹配表，这个表记录了每个位置上前缀子串与后缀子串的最长公共前缀长度。</li>
<li>在文本串中，使用模式串的部分匹配表来指导匹配。当发生不匹配时，根据部分匹配表的值，将模式串向右移动一定的距离，而不是直接从下一个字符重新开始匹配。</li>
</ol>
<p>​	KMP算法的优势在于它避免了不必要的比较，使得算法的时间复杂度降低到O(n + m)，其中n是文本串的长度，m是模式串的长度。这使得KMP算法在大规模文本中查找模式更加高效。</p>
<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h3 id="OSI和TCP-IP-模型各个层之间的协议和功能"><a href="#OSI和TCP-IP-模型各个层之间的协议和功能" class="headerlink" title="OSI和TCP&#x2F;IP 模型各个层之间的协议和功能"></a>OSI和TCP&#x2F;IP 模型各个层之间的协议和功能</h3><img src="https://github.com/ninuan/images/raw/main//images/image-20230816164258354.png" alt="image-20230816164258354" style="zoom: 67%;" />

<h3 id="简述一下层次路由的原理（叙述一下与自治系统相关的内部网关协议和外部网关协议）单工、半双工、全双工通信？"><a href="#简述一下层次路由的原理（叙述一下与自治系统相关的内部网关协议和外部网关协议）单工、半双工、全双工通信？" class="headerlink" title="简述一下层次路由的原理（叙述一下与自治系统相关的内部网关协议和外部网关协议）单工、半双工、全双工通信？"></a>简述一下层次路由的原理（叙述一下与自治系统相关的内部网关协议和外部网关协议）单工、半双工、全双工通信？</h3><p>​		层次路由的原理是将路由分成不同的层级,以提高路由效率和可扩展性。</p>
<p>​		自治系统内部使用内部网关协议(IGP),如<strong>RIP、OSPF</strong>、IS-IS等,用于在自治系统内部交换路由信息,计算最短路径。</p>
<p>​		自治系统之间使用外部网关协议(EGP),如<strong>BGP</strong>,用于在不同的AS之间交换路由可达信息,传递路由更新。BGP不计算最短路径,仅传递可达性信息。</p>
<p>​		单工通信:数据只能单向传输,如无线广播。</p>
<p>​		半双工通信:数据可以双向传输,但每个时刻只能单向传输,如对讲机。</p>
<p>​		全双工通信:数据可以同时双向传输,如电话通话。</p>
<p>​		综上所述,层次路由通过内部网关协议和外部网关协议分级交换路由信息,提高了路由可扩展性。通信模式决定了数据传输的方向性,单工只能单向,半双工必须轮流,全双工可以双向同时进行。</p>
<h3 id="协议三要素"><a href="#协议三要素" class="headerlink" title="协议三要素"></a>协议三要素</h3><p>​		语法，语义，时序</p>
<h3 id="香农公式？信道容量含义？带宽增加，信道容量怎么变？香农公式的前提条件？"><a href="#香农公式？信道容量含义？带宽增加，信道容量怎么变？香农公式的前提条件？" class="headerlink" title="香农公式？信道容量含义？带宽增加，信道容量怎么变？香农公式的前提条件？"></a>香农公式？信道容量含义？带宽增加，信道容量怎么变？香农公式的前提条件？</h3><p>​	$C &#x3D; B*log_2(1 + S&#x2F;N)$</p>
<p>​	信道容量表示在给定带宽下，在一定信噪比条件下，可以无误传输的最大比特率；带宽增加，在相同信噪比的情况下，信道容量C会增加。</p>
<p>​	香农公式的前提条件：系统中只存在加性高斯白噪声，而不存在其他干扰。</p>
<h3 id="CSMA-CD-协议"><a href="#CSMA-CD-协议" class="headerlink" title="CSMA&#x2F;CD 协议"></a>CSMA&#x2F;CD 协议</h3><p>​	先听后发，边发边听，冲突停发，随机延迟后重发（截断二进制指数退避算法）</p>
<p>​	载波侦听多路访问／碰撞检测(Carrier Sense Multiple Access with Collision Detection, CSMA&#x2F;CD) </p>
<p>协议是CSMA 协议的改进方案。” 载波帧听” 就是发送前先侦听，即每个站在发送数据之前先要检测 一下总线上是否有其他站点正在发送数据，若有则暂时不发送数据，等待信道变为空闲时再发送。” 碰撞检测” 就是边发送边侦听，即适配器边发送数据边检测信道上信号电压的变化情况，以 便判断自己在发送数据时其他站点是否也在发送数据。工作流程可简单概括为“先听后发，边听边 发（区别于CSMA 协议），冲突停发，随机重发”。 </p>
<ol>
<li><p>适配器从其父结点获得一个网络层数据报，准备一个以太网帧，并把该帧放到适配器缓冲区中。 </p>
</li>
<li><p>如果适配器侦听到信道空闲，那么它开始传输该帧。如果适配器侦听到信道忙，那么它将等待直至侦听到没有信号能量，然后开始传输该帧。</p>
</li>
</ol>
<ol start="3">
<li>在传输过程中，适配器检测来自其他适配器的信号能量。如果这个适配器传输了整帧，而没 有检测到来自其他适配器的信号能量，那么这个适配器完成该帧的传输。否则，适配器就须停止传输它的帧，取而代之传输一个48 比特的拥塞信号。</li>
</ol>
<ol start="4">
<li>在中止（即传输拥塞信号）后，适配器采用截断二进制指数退避算法等待一段随机时间后返回到步骤2。</li>
</ol>
<h3 id="TCP-和-UDP协议"><a href="#TCP-和-UDP协议" class="headerlink" title="TCP 和 UDP协议"></a>TCP 和 UDP协议</h3><ol>
<li><p>相同点：二者都是工作在传输层，双方的通信都要开放端口</p>
</li>
<li><p>不同点：</p>
<ol>
<li><p>TCP是可靠传输，UDP是不可靠传输</p>
</li>
<li><p>TCP是基于连接的协议，在正式收发数据前，必须和对方建立可靠的连接。  </p>
<p>UDP是和TCP相对应的协议，它是面向非连接的协议，它不与对方建立连接，而是直接把数据包发送出去</p>
</li>
<li><p>TCP是一种可靠的通信服务，负载相对而言比较大，TCP采用套接字（socket）或者端口（port）来建立通信。   </p>
<p>UDP是一种不可靠的网络服务，负载比较小。</p>
</li>
<li><p>TCP和UDP结构不同，TCP包括序号、确认信号、数据偏移、控制标志（通常说的URG、ACK、PSH、RST、SYN、FIN）、窗口、校验和、紧急指针、选项等信息。   </p>
<p>UDP包含长度和校验和信息。</p>
</li>
<li><p>TCP提供超时重发，丢弃重复数据，检验数据，流量控制等功能，保证数据能从一端传到另一端。   </p>
<p>UDP不提供可靠性，它只是把应用程序传给IP层的数据报发送出去，但是并不能保证它们能到达目的地。</p>
</li>
<li><p>TCP在发送数据包前在通信双方有一个三次握手机制，确保双方准备好，在传输数据包期间，TCP会根据链路中数据流量的大小来调节传送的速率，传输时如果发现有丢包，会有严格的重传机制，故而传输速度很慢。  </p>
<p>UDP在传输数据报前不用在客户和服务器之间建立一个连接，且没有超时重发等机制，故而传输速度很快。</p>
</li>
<li><p>TCP支持全双工和并发的TCP连接，提供确认、重传与拥塞控制。 </p>
<p>   UDP适用于哪些系统对性能的要求高于数据完整性的要求，需要“简短快捷”的数据交换、需要多播和广播的应用环境。</p>
</li>
</ol>
</li>
<li><p>TCP的三次握手：<a href="https://blog.csdn.net/guoweimelon/article/details/50878730">https://blog.csdn.net/guoweimelon/article/details/50878730</a></p>
<p>TCP的四次挥手：<a href="https://blog.csdn.net/guoweimelon/article/details/50879302">https://blog.csdn.net/guoweimelon/article/details/50879302</a></p>
<p>如果二次握手：</p>
<p>先假如出现了一种异常情况，即A发出的第一个连接请求报文段因为在某些网络节点上滞留了。由于超时重传，于是A又向B发起请求并成功建立了连接，在传输完数据之后，AB同之间释放了连接。</p>
<p>而在A和B已经释放连接之后，那个在网络上滞留的报文段又达到了B。这时候，B接收到报文以为是A发起的新的一次建立连接的请求，于是就向A发出确认建立连接报文段。而A此时并没有发起建立连接的请求，于是不予理睬。但是B以为新的连接已经建立，一直等待A发送数据，于是B的许多资源就浪费了。</p>
</li>
<li><p>TCP协议保证数据传输可靠性的方式主要有：校验和；序列号；确认应答；超时重传；连接管理；流量控制；拥塞控制；</p>
<p><a href="https://blog.csdn.net/liuchenxia8/article/details/80428157?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164024563516780274155503%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164024563516780274155503&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-80428157.pc_search_insert_es_download&utm_term=TCP%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93&spm=1018.2226.3001.4187">TCP可靠传输</a></p>
</li>
<li><p>TCP拥塞控制中，<a href="https://blog.csdn.net/sinat_21112393/article/details/50810053?ops_request_misc=&request_id=&biz_id=102&utm_term=%E5%9C%A8TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E4%B8%AD%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E6%85%A2%E5%BC%80%E5%A7%8B%E3%80%81%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D%E3%80%81%E5%BF%AB%E9%87%8D%E4%BC%A0%E5%92%8C%E5%BF%AB%E6%81%A2%E5%A4%8D%E7%AE%97&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-50810053.pc_search_result_control_group&spm=1018.2226.3001.4187">慢开始，拥塞避免，快重传和快恢复算法</a></p>
</li>
</ol>
<h3 id="流量控制和拥塞是什么关系？"><a href="#流量控制和拥塞是什么关系？" class="headerlink" title="流量控制和拥塞是什么关系？"></a>流量控制和拥塞是什么关系？</h3><p>​	流量控制解决的是发送方和接收方速率不匹配的问题；拥塞控制解决的是避免网络资源被耗尽的问题。流量控制是通过滑动窗口来实现的；拥塞控制是通过拥塞窗口来实现的。</p>
<p>​	拥塞控制是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况；常用的方法就是：慢开始、拥塞避免、快重传、快恢复。 </p>
<p>​	流量控制是作用于接收者的，它是控制发送者的发送速度从而使接收者来得及接收，防止分组丢失的。</p>
<h3 id="两个服务器之间网络已经联通，却收不到彼此的UDP报文原因"><a href="#两个服务器之间网络已经联通，却收不到彼此的UDP报文原因" class="headerlink" title="两个服务器之间网络已经联通，却收不到彼此的UDP报文原因"></a>两个服务器之间网络已经联通，却收不到彼此的UDP报文原因</h3><p>​	可能的原因很多，比如设置了acl（访问控制列表），禁用了某些端口，网络拥塞，丢包等</p>
<p>​	主要丢包原因</p>
<ol>
<li><p>接收端处理时间过长导致丢包</p>
</li>
<li><p>发送的包巨大丢包</p>
</li>
<li><p>发送的包较大，超过接受者缓存导致丢包</p>
</li>
<li><p>发送的包频率太快。</p>
</li>
<li><p>局域网内不丢包，公网上丢包</p>
</li>
</ol>
<h3 id="网卡是什么？功能？"><a href="#网卡是什么？功能？" class="headerlink" title="网卡是什么？功能？"></a>网卡是什么？功能？</h3><p>​	网卡是工作在<strong>链路层</strong>的网络组件，是局域网中连接计算机和传输介质的接口，不仅能实现与局域网传输介质之间的物理连接和电信号匹配，还涉及<strong>帧的发送与接收、帧的封装与拆封、介质访问控制、数据的编码与解码以及数据缓存的功能</strong>等。</p>
<p>​	网卡的作用：</p>
<p>​	网络是通过<strong>模拟信号将信息转化为电流传播</strong>的，网卡在这里面就充当了一个解码器的作用，将电信号重新转换文文字图像等就是网卡的责任。网卡的其他功能还有监控上传及下载流量，控制网速稳定的作用，它就相当于电脑的港口，所有信息上传到网络之前都要先到网卡这里走一遭。</p>
<p>​	每台电脑都有网卡，没有网卡无法上网。</p>
<h3 id="简述下DNS域名解析的过程"><a href="#简述下DNS域名解析的过程" class="headerlink" title="简述下DNS域名解析的过程"></a>简述下DNS域名解析的过程</h3><ol>
<li><p>当客户机提出查询请求时，首先在本地计算机的缓存中查找。如果在本地无法获得查询信息，则将查询请求发给DNS服务器。</p>
</li>
<li><p>首先客户机将域名查询请求发送到本地DNS服务器,当本地DNS服务器接到查询后，首先在该服务器管理的区域的记录中查找，如果找到该记录，则利用此记录进行解析；如果没有区域信息可以满足查询要求，服务器在本地的缓存中查找。</p>
</li>
<li><p>如果本地服务器不能在本地找到客户机查询的信息，将客户机请求发送到根域名DNS服务器。</p>
</li>
<li><p>根域名服务器负责解析客户机请求的根域部分，它将包含下一级域名信息的DNS服务器地址返回给客户机的DNS服务器地址。</p>
</li>
<li><p>客户机的DNS服务器利用根域名服务器解析的地址访问下一级DNS服务器，得到再下一级域我的DNS服务器地址。</p>
</li>
<li><p>按照上述递归方法逐级接近查询目标，最后在有目标域名的DNS服务器上找到相应IP地址信息。</p>
</li>
<li><p>客户机的本地DNS服务器将递归查询结果返回客户机。</p>
</li>
<li><p>客户机利用从本地DNS服务器查询得到的IP访问目标主机，就完成了一个解析过程。</p>
</li>
</ol>
<h3 id="点击网页一次HTTP请求过程"><a href="#点击网页一次HTTP请求过程" class="headerlink" title="点击网页一次HTTP请求过程?"></a>点击网页一次HTTP请求过程?</h3><ol>
<li>域名解析</li>
<li>将消息从PC传到服务器,使用IP、ARP协议和OSPF协议</li>
<li>发起TCP的3次握手</li>
<li>建立TCP连接后发起http请求</li>
<li>服务器响应http请求</li>
<li>浏览器解析html代码，并请求html代码中的资源</li>
<li>断开TCP连接</li>
<li>浏览器对网页进行渲染呈现给用户</li>
</ol>
<h3 id="简述一下Cookie-和-Session的区别"><a href="#简述一下Cookie-和-Session的区别" class="headerlink" title="简述一下Cookie 和 Session的区别"></a>简述一下Cookie 和 Session的区别</h3><ol>
<li><p>数据存放位置不同：cookie存储在客户的浏览器上，session存储在服务器上</p>
</li>
<li><p>安全程度不同：cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗</p>
</li>
<li><p>性能使用程度不同：session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能,考虑到减轻服务器性能方面，应当使用cookie</p>
</li>
<li><p>数据存储大小不同：单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie，而session则存储与服务端，浏览器对其没有限制</p>
</li>
<li><p>会话机制不同：</p>
<p>session会话机制：session会话机制是一种服务器端机制，它使用类似于哈希表（可能还有哈希表）的结构来保存信息。</p>
<p>cookies会话机制：cookie是服务器存储在本地计算机上的小块文本，并随每个请求发送到同一服务器。 Web服务器使用HTTP标头将cookie发送到客户端。在客户端终端，浏览器解析cookie并将其保存为本地文件，该文件自动将来自同一服务器的任何请求绑定到这些cookie</p>
</li>
</ol>
<p><a href="https://www.cnblogs.com/zyf-zhaoyafei/p/4716297.html">计算机网络之面试常考</a></p>
<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h3 id="操作系统的特点？功能？"><a href="#操作系统的特点？功能？" class="headerlink" title="操作系统的特点？功能？"></a>操作系统的特点？功能？</h3><p>​	操作系统特点：操作系统的四个基本特征是并发,共享,异步,虚拟。而每个操作系统又有其独特的特征，如我们常用的linux系统有开放性;多用户多任务;设备的独立性;强大的网络功能和网络可靠性等特点。</p>
<p>​	操作系统的功能：管理计算机系统的全部软、硬件资源 , 合理组织计算机的工作流程 , 以达到充分发挥计算机资源的效率 , 为用户提供友好界面</p>
<h3 id="中断和系统调用的区别"><a href="#中断和系统调用的区别" class="headerlink" title="中断和系统调用的区别"></a>中断和系统调用的区别</h3><p>​	中断分两种，硬中断和软中断；硬中断是实实在在的硬件发出的中断，cpu检测到发生中断后，保护现场，查找中断向量地址，执行中断服务程序，之后，重新选择进程进行调度。软中断是由指令执行过程中发出的中断，但是并没有中断向量表，而是有对应的散转表，查找对应的中断号，转中断服务程序，之后的和硬中断相同。</p>
<pre><code> 系统调用是软中断的一种。
</code></pre>
<h3 id="进程、线程的概念以及区别？进程间的通信方式？"><a href="#进程、线程的概念以及区别？进程间的通信方式？" class="headerlink" title="进程、线程的概念以及区别？进程间的通信方式？"></a>进程、线程的概念以及区别？进程间的通信方式？</h3><ol>
<li>​	区别：<ol>
<li>进程是具有一定功能的程序，是系统进行资源分配调度的一个独立单位</li>
<li>线程是进程的一个实体，是CPU调度分配的基本单位，线程之间基本上不拥有系统资源</li>
<li>一个程序至少有一个进程，一个进程至少有一个线程，资源分配给进程，同一个进程下所有线程共享该进程的资源</li>
</ol>
</li>
<li>进程间的通信方式：<a href="https://blog.csdn.net/zhaohong_bo/article/details/89552188">https://blog.csdn.net/zhaohong_bo/article/details/89552188</a></li>
<li>线程哪些资源共享？哪些资源不共享？<ol>
<li>共享：堆、全局变量、静态变量、文件等共有资源</li>
<li>独享：栈、寄存器</li>
</ol>
</li>
</ol>
<h3 id="进程有哪几种状态，状态之间的转换、进程调度策略？"><a href="#进程有哪几种状态，状态之间的转换、进程调度策略？" class="headerlink" title="进程有哪几种状态，状态之间的转换、进程调度策略？"></a>进程有哪几种状态，状态之间的转换、进程调度策略？</h3><ol>
<li><p>四种状态：就绪，运行，阻塞，终止</p>
<img src="https://github.com/ninuan/images/raw/main//images/image-20230817171832031.png" alt="image-20230817171832031" style="zoom:67%;" />
</li>
<li><p>进程调度策略</p>
<ol>
<li><p>先来先服务调度算法</p>
</li>
<li><p>短作业优先调度算法</p>
</li>
<li><p>高优先权优先调度算法</p>
<ol>
<li>非抢占式优先权算法</li>
<li>抢占式优先权调度算法</li>
</ol>
</li>
<li><p>高响应比优先调度算法</p>
<p>$R_p &#x3D; \frac{等待时间+要求服务时间}{要求服务时间} &#x3D; \frac{响应时间}{要求服务时间}$</p>
</li>
<li><p>时间片轮转法</p>
</li>
<li><p>多级反馈队列调度算法</p>
<ol>
<li>应设置多个就绪队列，并为各个队列赋予不同的优先级</li>
<li>当一个新进程进入内存后，首先将它放入第一队列的末尾，按FCFS原则排队等待调度</li>
<li>仅当第一队列空闲时，调度程序才调度第二序列中的进程运行</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="什么是死锁？死锁产生的四个必要条件？如何预防死锁？"><a href="#什么是死锁？死锁产生的四个必要条件？如何预防死锁？" class="headerlink" title="什么是死锁？死锁产生的四个必要条件？如何预防死锁？"></a>什么是死锁？死锁产生的四个必要条件？如何预防死锁？</h3><ol>
<li>死锁：是指多个进程因竞争资源而造成的一种僵局(互相等待)，若无外力作用，这些进程都将无法向前推进</li>
<li>四个必要条件：<ol>
<li>互斥条件</li>
<li>请求和保持条件</li>
<li>不剥夺条件</li>
<li>环路等待条件</li>
</ol>
</li>
<li>产生死锁的原因：<ol>
<li>竞争不可抢占型资源</li>
<li>竞争可消耗型资源（硬件中断、信号、消息、缓冲区内的消息等）</li>
<li>进程推进顺序不当</li>
</ol>
</li>
<li>如何预防死锁：<ol>
<li>资源一次性分配（一次性分配所有资源，这样就不会再有请求了，破坏了请求条件）</li>
<li>允许程序获得运行初期条件的所有资源后开始运行，过程中逐步释放给自己的已用完的资源，然后再请求新的资源（破坏请求保持条件）</li>
<li>可剥夺资源：即当某进程获得了部分资源，但得不到其他资源，则释放已占有的资源（破坏不可剥夺条件）</li>
<li>资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请资源，释放则相反（破坏环路等待条件）</li>
</ol>
</li>
</ol>
<h3 id="哲学家进餐有哪些实现方式？"><a href="#哲学家进餐有哪些实现方式？" class="headerlink" title="哲学家进餐有哪些实现方式？"></a>哲学家进餐有哪些实现方式？</h3><ol>
<li>核心是保证至少有一位哲学家能拿到两只筷子就餐后释放筷子：<ol>
<li>最多只允许n-1个哲学家拿起筷子就餐</li>
<li>资源分级算法，奇数号哲学家先拿左边的筷子，偶数号哲学家先拿右边的筷子</li>
<li>设立规则，当一位哲学家拿起一只筷子时，另一个筷子无法得到，则放下刚刚拿起的筷子</li>
<li>服务生算法，一次只允许一名哲学家进餐，等到这名哲学家就餐完毕后才允许其他哲学家进餐</li>
</ol>
</li>
</ol>
<h3 id="简述下银行家算法"><a href="#简述下银行家算法" class="headerlink" title="简述下银行家算法"></a>简述下银行家算法</h3><p>银行家算法是一种最有代表性的避免死锁的算法。在避免死锁方法中允许进程动态地申请资源，但系统在进行资源分配之前，应先计算此次分配资源的安全性，若分配不会导致系统进入不安全状态，则分配，否则等待。为实现银行家算法，系统必须设置若干数据结构。</p>
<p>银行家算法中的数据结构</p>
<p>为了实现银行家算法，必须设置以下四个数据结构:</p>
<ol>
<li><p>可利用资源向量Available:其初始值是系统中所配置的该类全部可用资源的数目。</p>
</li>
<li><p>最大需求矩阵Max:它定义了系统中n个进程中的每一个进程对m类资源的最大需求。</p>
</li>
<li><p>分配矩阵Allocation:它定义了系统中每一类资源当前已分配给每一个进程的资源数。</p>
</li>
<li><p>需求矩阵Need：用一表示每一个进程尚需的各类资源数。</p>
</li>
</ol>
<h3 id="分页的作用，好处？和分段有什么区别？"><a href="#分页的作用，好处？和分段有什么区别？" class="headerlink" title="分页的作用，好处？和分段有什么区别？"></a>分页的作用，好处？和分段有什么区别？</h3><ol>
<li>页是信息的物理单位，分页是为了实现非连续分配，以便解决内存碎片问题，或者说分页是由于系统管理的需要。段是信息的逻辑单位，它含有一组意义相对完整的信息，分段的目的是为了更好的实现共享，满足用户的需求。</li>
<li>页的大小固定且有系统确定，将逻辑地址划分为页号和业内地址是有机器硬件实现的，而段的长度却不固定，决定于用户所编写的程序，通常由编译程序在对源程序进行编译时根据信息的性质来划分</li>
<li>分页的作业地址空间是一维的；分段的地址空间是二维的</li>
</ol>
<h3 id="什么是虚拟内存？什么是共享内存？"><a href="#什么是虚拟内存？什么是共享内存？" class="headerlink" title="什么是虚拟内存？什么是共享内存？"></a>什么是虚拟内存？什么是共享内存？</h3><ol>
<li>虚拟内存是计算机系统内存管理的一种技术，它使得应用程序认为它拥有连续可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。与没有使用虚拟内存技术的系统相比，使用这种技术的系统使得大型程序的编写变得更容易，对真正的物理内存（例如RAM）的使用也更有效率</li>
<li>共享内存是最快速的进程间通信机制，操作系统在几个进程的地址空间上映射一段内存，然后这几个进程可以在不需要调用操作系统函数的情况下在那段内存上进行读&#x2F;写操作</li>
</ol>
<h3 id="页面置换算法？"><a href="#页面置换算法？" class="headerlink" title="页面置换算法？"></a>页面置换算法？</h3><ol>
<li>最佳置换算法（OPT）：每次选择淘汰的页面将是以后永不使用，或者在最长时间内不再被访问的页面，这样可以保证最低的缺页率</li>
<li>先进先出置换算法（FIFO）：每次选择淘汰的页面是最早进入内存的页面</li>
<li>最近最久未使用置换算法：每次淘汰的页面是最近最久未使用的页面</li>
<li>时钟置换算法：为每个页面设置一个访问位，再将内存中的页面都通过链接指针链接成一个循环队列。当某个页面被访问时，其访问位置设置为1，当需要淘汰一个页面时，只需检查页的访问位。如果是0，就选择该页换出；如果是1，暂不换出，将访问位改为0，继续检查下一个页面，若第一轮 扫描中所有的页面都是1，则将这些页面的访问位一次置为0后，再进行第二轮扫描（第二轮扫描中一定会有访问位为0的页面，因此简单的CLOCK算法选择一个淘汰页面最多会经过两轮扫描）</li>
<li>改进型时钟置换算法：<a href="https://www.jianshu.com/p/18285ecffbfb">https://www.jianshu.com/p/18285ecffbfb</a></li>
</ol>
<h3 id="磁盘调度算法以及磁盘空间存储管理？"><a href="#磁盘调度算法以及磁盘空间存储管理？" class="headerlink" title="磁盘调度算法以及磁盘空间存储管理？"></a>磁盘调度算法以及磁盘空间存储管理？</h3><p><a href="https://blog.csdn.net/lishanleilixin/article/details/89709194">https://blog.csdn.net/lishanleilixin/article/details/89709194</a></p>
<h1 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h1><h3 id="冯诺依曼机的体系结构"><a href="#冯诺依曼机的体系结构" class="headerlink" title="冯诺依曼机的体系结构"></a>冯诺依曼机的体系结构</h3><img src="https://github.com/ninuan/images/raw/main//images/image-20230818142451335.png" alt="image-20230818142451335" style="zoom: 67%;" />

<p>​	主要由五大部件组成：</p>
<ol>
<li>存储器用来存放数据和程序</li>
<li>运算器主要运行算数运算和逻辑运算，并将中间结果暂存到运算器中</li>
<li>控制器主要用来控制和指挥程序和数据的输入运行，以及处理运算结果</li>
<li>输入设备用来将人们熟悉的信息形式转换为机器能够识别的信息形式，常见的由键盘，鼠标等</li>
<li>输出设备可以将机器运算结果转换为人们熟悉的信息形式，如打印机输出，显示器输出等</li>
</ol>
<h3 id="衡量计算机性能指标"><a href="#衡量计算机性能指标" class="headerlink" title="衡量计算机性能指标"></a>衡量计算机性能指标</h3><ol>
<li><p>吞吐量：表征一台计算机在某一时间间隔内能够处理的信息量，单位是字节&#x2F;秒</p>
</li>
<li><p>响应时间：表征从输入有效到系统产生响应之间的时间度量，用时间单位来度量</p>
</li>
<li><p>利用率：表示在给定的时间间隔内，系统被实际使用的时间所占的比例，一般用百分比表示</p>
</li>
<li><p>处理机字长：指处理机运算器中一次能够完成二进制运算的位数，字长越长，表示计算的精度越高</p>
</li>
<li><p>总线宽度：一般指CPU中运算器与存储器之间进行互连的内部总线二进制位数</p>
</li>
<li><p>存储器容量：存储器中所有存储单元的总数目，通常用KB等表示</p>
</li>
<li><p>存储器带宽：存储器的速度指标，单位时间内从存储器读出的二进制数信息量，一般用字节数&#x2F;秒表示</p>
</li>
<li><p>主频&#x2F;时间周期：CPU的工作节拍受主时钟控制，主时钟不断产生固定频率的时钟，主时钟的频率（f）叫CPU的主频。度量单位是MHz、GHz。   主频的倒数称为CPU时钟周期（T），即T&#x3D;1&#x2F;f，度量单位是微秒、纳秒。</p>
</li>
<li><p>CPU执行时间：表示CPU执行一段程序所占用的CPU时间，可用下式计算：   CPU执行时间 ＝   CPU时钟周期数 × CPU时钟周期长 CPI：表示每条指令周期数，即执行一条指令所需的平均时钟周期数。  用下式计算：</p>
<p>MIPS:每秒百万条数据。MIPS是单位时间内的执行指令数，所以MIPS值越高说明机器速度越快。 MFLOPS是基于操作而非指令的，只能用来衡量机器浮点操作的性能，而不能体现机器的整体性能</p>
</li>
</ol>
<h3 id="源码、反码、补码"><a href="#源码、反码、补码" class="headerlink" title="源码、反码、补码"></a>源码、反码、补码</h3><ol>
<li>机器数</li>
</ol>
<p>​	一个数在计算机中的二进制表示形式, 叫做这个数的机器数。机器数是带符号的，在计算机用一个数的最高位存放符号, 正数为0, 负数为1.</p>
<p>​	比如，十进制中的数 +3 ，计算机字长为8位，转换成二进制就是00000011。如果是 -3 ，就是 10000011 。</p>
<p>​	那么，这里的 00000011 和 10000011 就是机器数。</p>
<ol start="2">
<li>真值</li>
</ol>
<p>​	因为第一位是符号位，所以机器数的形式值就不等于真正的数值。例如上面的有符号数 10000011，其最高位1代表负，其真正数值是 -3 而不是形式值131（10000011转换成十进制等于131）。</p>
<p>​	所以，为区别起见，将带符号位的机器数对应的真正数值称为机器数的真值。</p>
<p>​	例：0000 0001的真值 &#x3D; +000 0001 &#x3D; +1，1000 0001的真值 &#x3D; –000 0001 &#x3D; –1</p>
<ol start="3">
<li>原码</li>
</ol>
<p>​	原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值. 比如如果是8位二进制:</p>
<p>​	[+1]原 &#x3D; 0000 0001 [-1]原 &#x3D; 1000 0001</p>
<p>​	第一位是符号位. 因为第一位是符号位, 所以8位二进制数的取值范围就是:</p>
<p>​	[1111 1111 , 0111 1111]&#x3D;&#x3D;&gt;[-127 , 127]</p>
<ol start="4">
<li>反码</li>
</ol>
<p>​	反码的表示方法是:</p>
<p>​	l <strong>正数的反码是其本身</strong></p>
<p>​	l <strong>负数的反码是在其原码的基础上, 符号位不变，其余各个位取反</strong>.</p>
<p>​	[+1] &#x3D; [00000001]原 &#x3D; [00000001]反 [-1] &#x3D; [10000001]原 &#x3D; [11111110]反</p>
<ol start="5">
<li>补码</li>
</ol>
<p>​	补码的表示方法是:</p>
<p>​	l 正数的补码就是其本身</p>
<p>​	l 负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)</p>
<p>​	[+1] &#x3D; [00000001]原 &#x3D; [00000001]反 &#x3D; [00000001]补 [-1] &#x3D; [10000001]原 &#x3D; [11111110]反 &#x3D; [11111111]补</p>
<h3 id="奇偶校验、汉明码校验、循环冗余校验"><a href="#奇偶校验、汉明码校验、循环冗余校验" class="headerlink" title="奇偶校验、汉明码校验、循环冗余校验"></a>奇偶校验、汉明码校验、循环冗余校验</h3><ol>
<li><p>奇偶校验：</p>
<ol>
<li><p>奇校验：使完整编码（有效位和校验位）中的”1”的个数为奇数个</p>
</li>
<li><p>偶校验：使完整编码（有效位和校验位）中的”1”的个数为偶数个</p>
<table>
<thead>
<tr>
<th>待编有效信息</th>
<th>奇校验码</th>
<th>偶校验码</th>
</tr>
</thead>
<tbody><tr>
<td>10111010</td>
<td>101110100</td>
<td>101110101</td>
</tr>
<tr>
<td>11010010</td>
<td>110100101</td>
<td>110100100</td>
</tr>
</tbody></table>
<p>因此，如果是奇校验，当待编有效信息的”1”为奇数个，在最后添0，偶数个添1，偶校验相反</p>
</li>
<li><p>奇偶校验实际上就是对我们DnDn-1…D0进行异或运算（两两相同为0，不同为1），最后偶校验生成0，奇校验生成1，正确，反之错误。 </p>
<p>上面表格，第一个我们使用奇校验，第二个使用偶校验。</p>
<p>第一个奇校验：1⊕0⊕1⊕1⊕1⊕0⊕1⊕0⊕0&#x3D;1</p>
<p>第二个偶校验：1⊕1⊕0⊕1⊕0⊕0⊕1⊕0⊕0&#x3D;0</p>
</li>
</ol>
</li>
<li><p>汉明码校验：<a href="https://blog.csdn.net/zhang175gl/article/details/88637223">https://blog.csdn.net/zhang175gl/article/details/88637223</a></p>
</li>
<li><p>循环冗余校验：<a href="https://blog.csdn.net/liyuanbhu/article/details/7882789">https://blog.csdn.net/liyuanbhu/article/details/7882789</a></p>
</li>
</ol>
<h3 id="存储器的分类"><a href="#存储器的分类" class="headerlink" title="存储器的分类"></a>存储器的分类</h3><p>​	<img src="https://github.com/ninuan/images/raw/main//images/image-20230819104127699.png" alt="image-20230819104127699" style="zoom: 67%;" /></p>
<p>​	RAM：随机存取存储器是与CPU直接交换数据的内部存储器。它可以随时读写，而且速度很快，通常作为操作系统或其他正在运行中的程序的临时数据存储媒介。当电源关闭时RAM不能保留数据。如果需要保存数据，就必须把它们写入一个长期的存储设备中（例如硬盘）。RAM和ROM相比，两者的最大区别是RAM在断电以后保存在上面的数据会自动消失，而ROM不会自动消失，可以长时间断电保存。</p>
<p>​	ROM：只读存储器。ROM所存数据，一般是装入整机前事先写好的，整机工作过程中只能读出，而不像随机存储器那样能快速地、方便地加以改写。ROM所存数据稳定，断电后所存数据也不会改变。</p>
<p>​	RAM可以分为SRAM（静态随机存储器）和DRAM（动态随机存储器）。</p>
<p>​	SRAM它是一种具有静止存取功能的内存，不需要刷新电路即能保存它内部存储的数据。优点是速度快，不必配合内存刷新电路，可提高整体的工作效率。缺点是集成度低，功耗较大，相同的容量体积较大，而且价格较高，少量用于关键性系统以提高效率。</p>
<p>​	DRAM是最为常见的系统内存。DRAM只能将数据保持很短的时间。为了保持数据，DRAM使用电容存储，所以必须隔一段时间刷新（refresh）一次，如果存储单元没有被刷新，存储的信息就会丢失。</p>
<p>​	SDRAM（同步动态随机存取存储器），是在DRAM的基础上发展而来，为DRAM的一种，同步是指Memory工作需要同步时钟，内部命令的发送与数据的传输都以时钟为基准；动态是指存储阵列需要不断的刷新来保证数据不丢失；随机是指数据不是线性依次存储，而是由指定地址进行数据读写。</p>
<p>​	DDR SDRAM又是在SDRAM的基础上发展而来，这种改进型的DRAM和SDRAM是基本一样的，不同之处在于它可以在一个时钟读写两次数据，这样就使得数据传输速度加倍了。这是目前电脑中用得最多的内存，而且它有着成本优势。</p>
<h3 id="CPU一个指令周期的流程是什么？"><a href="#CPU一个指令周期的流程是什么？" class="headerlink" title="CPU一个指令周期的流程是什么？"></a>CPU一个指令周期的流程是什么？</h3><img src="https://github.com/ninuan/images/raw/main//images/image-20230819104808648.png" alt="image-20230819104808648" style="zoom: 67%;" />

<h3 id="总线通讯的四种方式"><a href="#总线通讯的四种方式" class="headerlink" title="总线通讯的四种方式"></a>总线通讯的四种方式</h3><p><a href="https://blog.csdn.net/yuanyuan320/article/details/110244550">https://blog.csdn.net/yuanyuan320/article/details/110244550</a></p>
<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h3 id="一二三范式"><a href="#一二三范式" class="headerlink" title="一二三范式"></a>一二三范式</h3><ol>
<li>第一范式（1NF）：属性不可分。及数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即试题中的某个属性不能有多个值或者不能有重复的属性</li>
<li>第二范式（2NF）：每个非主属性完全函数依赖于键码，可以通过分解来满足2NF</li>
<li>第三范式（3NF）：非主属性不传递函数依赖于键码。简而言之，第三范式就是属性不依赖于其他非主属性</li>
</ol>
<h3 id="数据库有什么类型的数据库、关系型数据库的特点"><a href="#数据库有什么类型的数据库、关系型数据库的特点" class="headerlink" title="数据库有什么类型的数据库、关系型数据库的特点"></a>数据库有什么类型的数据库、关系型数据库的特点</h3><p><strong>数据库类型：</strong></p>
<ol>
<li><strong>关系型数据库（RDBMS）：</strong> 这是最常见的数据库类型之一，使用表格和行来组织数据，支持SQL查询语言。</li>
<li><strong>非关系型数据库（NoSQL）：</strong> 这是一类多样化的数据库类型，不使用传统的表格和行来组织数据，而是使用不同的数据模型。</li>
<li><strong>文档数据库：</strong> 存储类似于JSON或XML格式的文档，适合存储半结构化数据。</li>
<li><strong>键值存储数据库：</strong> 使用键值对存储数据，类似于字典或哈希表。</li>
<li><strong>列族数据库：</strong> 将数据存储为列族，适合存储具有不同属性的数据。</li>
<li><strong>图数据库：</strong> 专为存储图结构数据（节点和边）而设计，适用于复杂的关系和网络数据。</li>
</ol>
<p><strong>关系型数据库的特点：</strong></p>
<ol>
<li><strong>表格结构：</strong> 关系型数据库使用表格（也称为关系）来存储数据，每个表包含行和列，类似于Excel表格。</li>
<li><strong>预定义模式：</strong> 在关系型数据库中，您需要事先定义表的结构（列名、数据类型等），这称为数据库模式。</li>
<li><strong>SQL查询语言：</strong> 关系型数据库使用结构化查询语言（SQL）进行数据操作和查询，这是一种通用的标准语言。</li>
<li><strong>数据完整性：</strong> 关系型数据库提供数据完整性约束，如主键、外键和唯一约束，以保持数据的一致性和准确性。</li>
<li><strong>事务支持：</strong> 关系型数据库支持事务，允许将一系列操作组合成一个原子操作单元，确保数据的一致性。</li>
<li><strong>ACID属性：</strong> 关系型数据库遵循ACID属性，即原子性、一致性、隔离性和持久性，以保证数据的可靠性和完整性。</li>
<li><strong>数据关联：</strong> 通过主键和外键，关系型数据库可以建立表之间的关联，从而支持复杂的数据查询和分析。</li>
<li><strong>适合结构化数据：</strong> 关系型数据库适用于存储结构化和规范化的数据，例如金融数据、用户信息等。</li>
</ol>
<h3 id="数据库有几种锁？"><a href="#数据库有几种锁？" class="headerlink" title="数据库有几种锁？"></a>数据库有几种锁？</h3><ol>
<li>共享（S）锁：多个事务可封锁一个共享页；任何事务都不能修改该页；通常是该页被读取完毕，S锁立刻被释放</li>
<li>排他（X）锁：仅允许一个事务封锁此页；其他任何事务必须等到X锁被释放才能对该页进行访问；X锁一直到事务结束才能被释放</li>
<li>更新（U）锁：用来预定要对此页施加X锁，它允许其他事务读，但不允许再施加U锁或X锁；当被读取的页将要被更新时，则升级为X锁；U锁一直到事务结束时才能被释放</li>
</ol>
<h3 id="数据库的三个完整性约束"><a href="#数据库的三个完整性约束" class="headerlink" title="数据库的三个完整性约束"></a>数据库的三个完整性约束</h3><ol>
<li><p>实体完整性，参照完整性和用户自定义完整性约束。实体完整性规定表的每一行在表中是唯一的实体。</p>
</li>
<li><p>参照完整性指两个表的主关键字和外关键字的数据一致，保证表之间的数据一致性，防止数据丢失或无意义的数据在数据库中扩散。</p>
</li>
<li><p>用户自定义完整性是不同数据库根据应用环境不同，用户定义的一些特殊约束条件</p>
</li>
</ol>
<h3 id="事务与锁？事务的四个特性是什么？"><a href="#事务与锁？事务的四个特性是什么？" class="headerlink" title="事务与锁？事务的四个特性是什么？"></a>事务与锁？事务的四个特性是什么？</h3><ol>
<li><p>事务：事务是指作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。 事务处理可以确保除非事务性单元内的所有操作都成功完成，否则不会永久更新面向数据的资源。通过将一组相关操作组合为一个要么全部成功要么全部失败的单元，可以简化错误恢复并使应用程序更加可靠。</p>
</li>
<li><p>锁：是用于解决隔离性的一种机制，事务的隔离级别通过锁的机制来实现</p>
</li>
<li><p>事务的四个特性（ACID）：</p>
<ol>
<li>原子性（Atomicity）：事务开始后所有操作，要么全部做完，要么全部不做，不可能停滞在中间环节。事务执行过程中出错，会回滚到事务开始前的状态，所有的操作就像没有发生一样。也就是说事务是一个不可分割的整体，就像化学中学过的原子，是物质构成的基本单位。</li>
<li>一致性（Consistency）：事务开始前和结束后，数据库的完整性约束没有被破坏 。比如A向B转账，不可能A扣了钱，B却没收到。</li>
<li>隔离性（Isolation）：同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。</li>
<li>持久性（Durability）：事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚。</li>
</ol>
</li>
<li><p>事务回滚和数据的不一致问题：如果在事务执行过程中发生错误，可以通过事务回滚来撤销已经执行的操作，将数据库恢复到事务开始前的状态，从而保证数据的一致性和完整性。例如，在一个包含多个操作的事务中，如果某个操作失败，数据库会自动回滚到事务开始之前的状态，确保没有残留的不一致数据。</p>
</li>
<li><p>ACID的保证：</p>
<p>数据库管理系统通过REDO和UNDO机制来保证ACID特性：</p>
<ul>
<li><strong>REDO（重做）机制：</strong> 当事务进行了修改但还未提交时，数据库会将这些修改记录在重做日志中。如果在事务提交之前发生崩溃，系统可以使用重做日志来重新应用这些操作，使数据回到一致的状态。</li>
<li><strong>UNDO（撤销）机制：</strong> 当事务进行了修改并已经提交，但在事务提交后系统发生了崩溃，UNDO日志用于回滚事务的修改，将数据恢复到事务开始前的状态。</li>
</ul>
</li>
</ol>
<h3 id="如何优化数据库？提高查询的效率？"><a href="#如何优化数据库？提高查询的效率？" class="headerlink" title="如何优化数据库？提高查询的效率？"></a>如何优化数据库？提高查询的效率？</h3><p><a href="https://blog.csdn.net/xlgen157387/article/details/44156679">https://blog.csdn.net/xlgen157387/article/details/44156679</a></p>
<h1 id="软件工程"><a href="#软件工程" class="headerlink" title="软件工程"></a>软件工程</h1><h3 id="软件工程三要素？"><a href="#软件工程三要素？" class="headerlink" title="软件工程三要素？"></a>软件工程三要素？</h3><p>软件工程三要素包括：方法、工具和过程</p>
<h3 id="软件开发模型？"><a href="#软件开发模型？" class="headerlink" title="软件开发模型？"></a>软件开发模型？</h3><ol>
<li><strong>瀑布模型（Waterfall Model）：</strong> 瀑布模型是最传统的开发模型，将开发过程划分为严格的阶段，如需求分析、系统设计、编码、测试和维护。每个阶段完成后才进入下一个阶段。适用于需求相对稳定、项目规模较小的项目。</li>
<li><strong>迭代与增量模型（Iterative and Incremental Model）：</strong> 这些模型强调反复迭代开发和逐步增加功能。项目被划分为多个小的迭代周期，每个迭代都涵盖了整个开发流程，但只实现了部分功能。适用于需求可能变化的项目，可以更灵活地应对变化。</li>
<li><strong>敏捷模型（Agile Model）：</strong> 敏捷开发强调快速响应需求变化、持续交付、团队合作和迭代开发。常见的敏捷方法包括Scrum、Kanban和极限编程（XP）等。</li>
<li><strong>螺旋模型（Spiral Model）：</strong> 螺旋模型将风险管理融入到开发流程中，每个循环称为一个螺旋，包括规划、风险分析、工程构建和评审。适用于大规模项目和具有较高风险的项目。</li>
<li><strong>V模型（V-Model）：</strong> V模型将软件开发与测试活动紧密结合，每个开发阶段都有对应的测试阶段。适用于强调测试和验证的项目。</li>
<li><strong>脚手架模型（Scaffold Model）：</strong> 脚手架模型着重于通过快速生成原型来快速验证概念和需求，然后再基于原型构建稳定的解决方案。</li>
</ol>
<h3 id="黑盒测试和白盒测试有什么区别？"><a href="#黑盒测试和白盒测试有什么区别？" class="headerlink" title="黑盒测试和白盒测试有什么区别？"></a>黑盒测试和白盒测试有什么区别？</h3><ol>
<li>测试方法不同：<ol>
<li>黑盒测试：功能测试，是通过测试来检测每个功能是否都能正常使用。</li>
<li>白盒测试：称结构测试、透明盒测试、逻辑驱动测试或基于代码的测试。</li>
</ol>
</li>
<li>测试目的不同：<ol>
<li>黑盒测试：把程序看作一个不能打开的黑盒子，在完全不考虑程序内部结构和内部特性的情况下，在程序接口进行测试，只检查程序功能是否按照需求规格说明书的规定正常使用，程序是否能适当地接收输入数据而产生正确的输出信息。</li>
<li>白盒测试：通过检查软件内部的逻辑结构，对软件中的逻辑路径进行覆盖测试。在程序不同地方设立检查点，检查程序的状态，以确定实际运行状态与预期状态是否一致。</li>
</ol>
</li>
<li>测试原则不同：<ol>
<li>黑盒测试：以用户的角度，从输入数据与输出数据的对应关系出发进行测试的。很明显，如果外部特性本身设计有问题或规格说明的规定有误，用黑盒测试方法是发现不了的。</li>
<li>白盒测试：一个模块中的所有独立路径至少被测试一次。所有逻辑值均需测试true和false两种情况。</li>
</ol>
</li>
</ol>
<h3 id="介绍下MVC模式"><a href="#介绍下MVC模式" class="headerlink" title="介绍下MVC模式"></a>介绍下MVC模式</h3><p>MVC 模式（Model–view–controller）是软件工程中的一种软件架构模式，它把软件系统分为三个基本部分：模型（Model）、视图（View）和控制器（Controller）。</p>
<p>MVC 模式的目的是实现一种动态的程序设计，简化后续对程序的修改和扩展，并且使程序某一部分的重复利用成为可能。除此之外，MVC 模式通过对复杂度的简化，使程序的结构更加直观。软件系统在分离了自身的基本部分的同时，也赋予了各个基本部分应有的功能。专业人员可以通过自身的专长进行相关的分组：</p>
<p><strong>模型（Model）</strong>：程序员编写程序应有的功能（实现算法等等）、数据库专家进行数据管理和数据库设计(可以实现具体的功能)；</p>
<p><strong>控制器（Controller）</strong>：负责转发请求，对请求进行处理；</p>
<p><strong>视图（View）</strong>：界面设计人员进行图形界面设计。</p>
<p>具体：<a href="https://blog.csdn.net/liitdar/article/details/86685880">https://blog.csdn.net/liitdar/article/details/86685880</a></p>
<h1 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h1><h3 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h3><ol>
<li><p>相同点：都是地址的概念；指针指向一块内存，它的内容是所指内存的地址；而引用则是某块内存的别名。</p>
</li>
<li><p>不同点：</p>
<ol>
<li>指针是一个实体，而引用仅是个别名；</li>
<li>引用只能在定义时被初始化一次，之后不可变；指针可变；引用“从一而终”，指针可以“见异思迁”；</li>
<li>引用没有const，指针有const，const的指针不可变；</li>
<li>引用不能为空，指针可以为空；</li>
<li>“sizeof 引用”得到的是所指向的变量(对象)的大小，而“sizeof 指针”得到的是指针本身的大小；</li>
<li>指针和引用的自增(++)运算意义不一样；</li>
<li>引用是类型安全的，而指针不是 (引用比指针多了类型检查）</li>
</ol>
</li>
</ol>
<p>参考：<a href="https://blog.csdn.net/xdrt81y/article/details/18004129">https://blog.csdn.net/xdrt81y/article/details/18004129</a></p>
<h3 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h3><p><a href="https://blog.csdn.net/jiang7701037/article/details/98738487">https://blog.csdn.net/jiang7701037/article/details/98738487</a></p>
<h3 id="java和c-和c的区别"><a href="#java和c-和c的区别" class="headerlink" title="java和c++和c的区别"></a>java和c++和c的区别</h3><ol>
<li>Java不能在类之外的地方定义全局变量，只能在一个类中定义静态变量来实现一个全局变量。</li>
</ol>
<p>​	C&#x2F;C++可以直接在类之外定义全局变量。</p>
<p>​	Java can’t define global variables outside a class, it can only define static variables in a class as a global variable.</p>
<ol start="2">
<li>Java不支持C&#x2F;C++的goto语句，而是通过try、catch来代替C&#x2F;C++的goto来处理异常时控制。</li>
</ol>
<p>​	Java doesn’t support “goto” statements of C&#x2F;C++, but uses try&#x2F;catch syntax instead of “goto” for exception control.</p>
<ol start="3">
<li>C&#x2F;C++可以通过指针进行内存地址操作，例如通过指针对某内存地址进行显式类型转换，而这种操作访问私有成员破坏了安全性。</li>
</ol>
<p>​	Java对指针进行完全的控制，不能在程序中进行任何指针操作，Java中的数组作为类实现，解决了关于数组的很多C&#x2F;C++难以检查的错误。</p>
<p>​	C&#x2F;C++ can operate memory address through pointer. For Example, C&#x2F;C++ makes explicitly conversion to a memory address by pointer, which destroys the security of the program because it accesses private members. Java Controls pointer completely, and can not operate any pointer in the program. The array in Java is implemented as a class, which solves many errors about array which are difficult to check in c&#x2F;c++.</p>
<ol start="4">
<li>在C语言中通过malloc和free函数分配和释放内存；C++中可以通过new和delete进行内存的分配和释放。在Java中通过new运算符分配内存，进行对象实例化，而分配内存时随着程序运行动态分配，且Java能够进行自动管理和自动垃圾回收，防止内存资源产生的操作错误和浪费。</li>
</ol>
<p>​	In C language, malloc function and free function are used to allocate and release memory; In C + +, memory can be allocated and released by new and delete keywords. In Java, the new operator is used to allocate memory and instantiate objects, and the allocated memory is dynamically allocated with the running of the program. Java can automatically manage memory and recycle garbage, so as to prevent memory operation errors and memory waste.</p>
<ol start="5">
<li>C&#x2F;C++对于不同的平台，数据类型的长度不同，代码不可移植。Java对数据类型总是分配固定长度位数，保证平台无关性。</li>
</ol>
<p>​	The length of data type of C&#x2F;C++ is different in different platforms, so the code is not portable. Java always allocates a fixed number of bits to data type to ensure platform independence.</p>
<ol start="6">
<li>C++可以通过指针进行任意类型的转换，Java在进行类型转换时会进行类型相容性检查，防止不安全的转换。</li>
</ol>
<p>​	C++ can do any type conversion by pointer. Java will check the type compatibility to prevent unsafe conversion.</p>
<ol start="7">
<li>C&#x2F;C++中用头文件声明类的原型及全局变量、库函数，在大的系统中难以维护这些文件。Java不支持头文件，所有类成员的类型和访问权限都封装在一个类中，运行时系统对访问会进行控制防止对私有成员的操作；导入其他类要使用import语句。</li>
</ol>
<p>​	In C&#x2F;C++, header files are used to declare class prototypes, global variables and library functions, which are diffcult to maintain in large systems. Java does not support header files. The types and access rights of all class members are encapsulated in one class. When the program is running, the system will control the access to prevent the operation of private members.</p>
<ol start="8">
<li>C++中的结构体和联合体所有成员都是共有的，这有一定的安全问题。Java中没有结构体和联合体，一切内容都封装在类中。</li>
</ol>
<p>​	All members of C++ structure and union are public, so there are some security problems. There is no structure or union in Java, everything is encapsulated in class.</p>
<ol start="9">
<li>C++支持宏定义，Java不支持宏定义，而是通过final来声明一个常量，实现宏定义中常量的定义。</li>
</ol>
<p>​	C + + supports macro definition. Java does not support macro definition, but declares a constant through the final keyword to realize the definition of constant equivalent to macro definition.</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Learn</tag>
      </tags>
  </entry>
</search>
