<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>vpn搭建教程</title>
    <url>/2023/07/19/VPN%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="VPN搭建教程"><a href="#VPN搭建教程" class="headerlink" title="VPN搭建教程"></a>VPN搭建教程</h1><p>DNS书写：</p>
<ol>
<li><p>安装trojan</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">sudo bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/trojan-gfw/trojan-quickstart/master/trojan-quickstart.sh)&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装nginx搭建https伪装</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">sudo yum update //更新软件包</span><br><span class="line"></span><br><span class="line">//安装nginx</span><br><span class="line">sudo yum install epel-release</span><br><span class="line">sudo yum install nginx</span><br><span class="line"></span><br><span class="line">//启动nginx</span><br><span class="line">systemctl enable nginx; systemctl start nginx</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">默认情况下，Nginx 会监听 80 端口，您可以通过在浏览器中输入服务器的 IP 地址或域名来验证 Nginx 是否安装成功。如果您能够看到 Nginx 的欢迎页面，则表示安装成功。如果未能成功启动 Nginx，请检查 Nginx 的配置文件是否正确，并检查是否有其它服务占用了 80 端口。</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">// nginx页面地址在/usr/share/nginx/html  修改下面的nginx即可搭建成功界面</span><br></pre></td></tr></table></figure>
</li>
<li><p>证书申请</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">//安装certbot</span><br><span class="line">sudo yum install certbot</span><br><span class="line"></span><br><span class="line">// 申请证书</span><br><span class="line">sudo certbot certonly --webroot -w /path/to/your/application/root --domain example.com --email your-email@example.com</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">/path/to/your/application/root 填写自己前端网页地址，例如本实例即为/usr/share/nginx/html</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>4.完善</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//放前端页面</span><br><span class="line">具体位置在nginx.conf里面可以直接找。</span><br><span class="line">//改nginx配置</span><br><span class="line">直接复制nginx.conf替换原来的。</span><br><span class="line">VPS的nginx.conf位置：/etc/nginx/nginx.conf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//改trojan配置：</span><br><span class="line">将config.json文件复制替换原来的：</span><br><span class="line">Trojan的config.json位置:/usr/local/etc/trojan/config.json</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//设置重启和开机自启动，这个直接问chatgpt</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bbr加速安装</span><br><span class="line">//先安装wget</span><br><span class="line">yum install wget</span><br><span class="line"></span><br><span class="line">//安装bbr</span><br><span class="line">wget -N --no-check-certificate &quot;https://gist.github.com/zeruns/a0ec603f20d1b86de6a774a8ba27588f/raw/4f9957ae23f5efb2bb7c57a198ae2cffebfb1c56/tcp.sh&quot; &amp;&amp; chmod +x tcp.sh &amp;&amp; ./tcp.sh</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>vpn</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown配合图床上传图片到Github</title>
    <url>/2023/08/07/Markdown%E9%85%8D%E5%90%88%E5%9B%BE%E5%BA%8A%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E5%88%B0Github/</url>
    <content><![CDATA[<p>Markdown配合图床上传图片到Github</p>
<ol>
<li><p>获取token</p>
<ol>
<li><p>打开github，进入设置，找到<code>Developer settings</code></p>
</li>
<li><p>点击<code>Personal access tokens</code>，选择<code>Tokens(classic)</code></p>
</li>
<li><p>选择<code>Generate new token（classic）</code></p>
<img src="https://github.com/ninuan/images/raw/main//images/image-20230807222401180.png" alt="image-20230807222401180" style="zoom:50%;" />
</li>
<li><p>时限改为<code>No expiration</code>，选择<code>repo</code>，点击生成，保存生成的token后续使用</p>
<img src="https://github.com/ninuan/images/raw/main//images/image-20230807222619122.png" alt="image-20230807222619122" style="zoom:50%;" /></li>
</ol>
</li>
<li><p>进入typora，点击文件，偏好设置，选择PicGo-Core(command line)，图像中的其他选项按照下图所示进行选择</p>
</li>
</ol>
<img src="https://github.com/ninuan/images/raw/main//images/image-20230807221541947.png" alt="image-20230807221541947" style="zoom:50%;" />

<ol start="3">
<li>点击下载或更新，弹出的框选择下载</li>
</ol>
<img src="https://github.com/ninuan/images/raw/main//images/image-20230807221703975.png" alt="image-20230807221703975" style="zoom:50%;" />

<ol start="4">
<li><p>下载成功后，点击打开配置文件，填入下面的代码</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;picBed&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;current&quot;</span><span class="punctuation">:</span> <span class="string">&quot;github&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;github&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;repo&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ninuan/images&quot;</span><span class="punctuation">,</span>  <span class="comment">//填写自己的仓库名字</span></span><br><span class="line">      <span class="attr">&quot;branch&quot;</span><span class="punctuation">:</span> <span class="string">&quot;main&quot;</span><span class="punctuation">,</span> <span class="comment">//自己的分支，main或者master</span></span><br><span class="line">      <span class="attr">&quot;token&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span> <span class="comment">// 填写第一步获得的token </span></span><br><span class="line">      <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;images/&quot;</span><span class="punctuation">,</span>  <span class="comment">// 仓库中设置的文件名，可以设置，也可以不设置</span></span><br><span class="line">      <span class="attr">&quot;customUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://github.com/ninuan/images/raw/main/&quot;</span>  <span class="comment">// 这个位置按照对应的设置来填写网址，可以打开一个上传后的图片，将网址copy下来，eg.  https://github.com/ninuan/images/blob/main/images/202301051712715.png，对应的位置进行修改，raw一定要修改，否则可以上传但无法加载</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;uploader&quot;</span><span class="punctuation">:</span> <span class="string">&quot;github&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;transformer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;path&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;picgoPlugins&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;picgo-plugin-github-plus&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>点击<code>图片上传选项</code>，提示成功即代表创建成功（后续验证的时候如果出现上传失败，如果之前验证过，因为验证时候上传的图片名称是一样的，可以去仓库把图片删除一下即可，如果是自己上传的图片则没有影响，因为是按照当时的时间自动命的名字）</p>
<img src="https://github.com/ninuan/images/raw/main//images/image-20230807223357215.png" alt="image-20230807223357215" style="zoom:50%;" /></li>
</ol>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Typora</tag>
      </tags>
  </entry>
  <entry>
    <title>自建测速节点，解决V2rayN测速为0的问题</title>
    <url>/2023/07/21/%E8%87%AA%E5%BB%BA%E6%B5%8B%E9%80%9F%E8%8A%82%E7%82%B9%EF%BC%8C%E8%A7%A3%E5%86%B3V2rayN%E6%B5%8B%E9%80%9F%E4%B8%BA0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="本教程需要使用的网站或工具："><a href="#本教程需要使用的网站或工具：" class="headerlink" title="本教程需要使用的网站或工具："></a>本教程需要使用的网站或工具：</h3><ol>
<li><a href="https://www.cloudflare.com/">https://www.cloudflare.com/</a></li>
<li>一个域名（需要解析到cloudflare上面）</li>
<li>科学上网</li>
</ol>
<h3 id="如果不想花费力气，直接下载：测速"><a href="#如果不想花费力气，直接下载：测速" class="headerlink" title="如果不想花费力气，直接下载：测速"></a>如果不想花费力气，直接下载：<a href="https://short.ninuan.link/yxip">测速</a></h3><h3 id="教程："><a href="#教程：" class="headerlink" title="教程："></a>教程：</h3><ol>
<li><p>登录cloudflare，点击<code>Workers和Pages</code>，创建应用程序</p>
<img src="https://github.com/ninuan/images/raw/main//images/image-20230721144833007.png" alt="image-20230721144833007" style="zoom:50%;" />
</li>
<li><p>点击创建Worker，名称随意（但是不能跟已有的重复），点击部署</p>
<img src="https://github.com/ninuan/images/raw/main//images/image-20230721145006155.png" alt="image-20230721145006155" style="zoom:50%;" />
</li>
<li><p>点击编辑代码，进入之后把原先的代码删完，复制代码，粘贴，然后点击<strong>保存并部署</strong>（如果还是不能使用，替换第四行的链接，在<a href="https://github.com/XIU2/CloudflareSpeedTest/issues/168">https://github.com/XIU2/CloudflareSpeedTest/issues/168</a> 里面找到能用的链接就行）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">addEventListener</span>(<span class="string">&quot;fetch&quot;</span>, <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> url = <span class="keyword">new</span> <span class="title function_">URL</span>(event.<span class="property">request</span>.<span class="property">url</span>);</span><br><span class="line">  <span class="keyword">if</span> (url.<span class="property">pathname</span> == <span class="string">&quot;/&quot;</span> &amp;&amp; url.<span class="property">search</span> == <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">    url.<span class="property">href</span>=<span class="string">&quot;https://cloudflarest.itkyou.cf/100mb.zip&quot;</span></span><br><span class="line">    <span class="keyword">let</span> request = <span class="keyword">new</span> <span class="title class_">Request</span>(url, event.<span class="property">request</span>);</span><br><span class="line">    event.<span class="title function_">respondWith</span>(<span class="title function_">fetch</span>(request));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>回到Workers空间，找到<code>Custom Domains</code>，点击查看</p>
<img src="https://github.com/ninuan/images/raw/main//images/image-20230721145322954.png" alt="image-20230721145322954" style="zoom:50%;" />
</li>
<li><p>点击添加自定义域（域名需要在cloudflare存在解析，然后自己在域名前面添加二级域名即可）</p>
<img src="https://github.com/ninuan/images/raw/main//images/image-20230721145418347.png" alt="image-20230721145418347" style="zoom:50%;" />
</li>
<li><p>现在将添加的自定义域名放到V2rayN里面即可（最好使用最新版本）</p>
<img src="https://github.com/ninuan/images/raw/main//images/image-20230721145535312.png" alt="image-20230721145535312" style="zoom:50%;" /></li>
</ol>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>cloudflare</tag>
      </tags>
  </entry>
  <entry>
    <title>cloudflare创建自己的短链生成网站</title>
    <url>/2023/07/20/%E4%BD%BF%E7%94%A8cloudflare%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E7%9F%AD%E9%93%BE%E7%94%9F%E6%88%90%E7%BD%91%E7%AB%99/</url>
    <content><![CDATA[<h3 id="本教程需要使用的网站或工具："><a href="#本教程需要使用的网站或工具：" class="headerlink" title="本教程需要使用的网站或工具："></a>本教程需要使用的网站或工具：</h3><ol>
<li><a href="https://www.cloudflare.com/">https://www.cloudflare.com/</a></li>
<li>一个域名（需要解析到cloudflare上面）</li>
<li>科学上网</li>
</ol>
<h3 id="教程："><a href="#教程：" class="headerlink" title="教程："></a>教程：</h3><ol>
<li><p>登录cloudflare</p>
</li>
<li><p>点击<code>Workers 和 Pages</code></p>
</li>
<li><p>点击<strong>KV</strong></p>
<img src="https://github.com/ninuan/images/raw/main//images/image-20230720232556634.png" alt="image-20230720232556634" style="zoom:50%;" />
</li>
<li><p>点击创建命名空间，点击添加</p>
<img src="https://github.com/ninuan/images/raw/main//images/image-20230720232658914.png" alt="image-20230720232658914" style="zoom:50%;" />
</li>
<li><p>完成之后点击查看，输入密钥和值（随意，或者可以按照我的填写），点击添加条目</p>
<img src="https://github.com/ninuan/images/raw/main//images/image-20230720232900640.png" alt="image-20230720232900640" style="zoom:50%;" />
</li>
<li><p>点击概述，创建应用程序</p>
<img src="https://github.com/ninuan/images/raw/main//images/image-20230720233042717.png" alt="image-20230720233042717" style="zoom:50%;" />
</li>
<li><p>点击创建Worker，名称随意，点击部署</p>
<img src="https://github.com/ninuan/images/raw/main//images/image-20230720233249511.png" alt="image-20230720233249511" style="zoom:50%;" />
</li>
<li><p>点击编辑代码，进入之后把原先的代码删完，复制这个代码<code>https://github.com/a624587332/Url-Shorten-Worker/blob/main/index.js</code>,粘贴，修改178行成baidu.com等国内网站或者你自己的博客地址也行，然后点击保存并部署</p>
<img src="https://github.com/ninuan/images/raw/main//images/image-20230720233559571.png" alt="image-20230720233559571" style="zoom:50%;" />
</li>
<li><p>回到workers空间，点击设置，点击变量</p>
<img src="https://github.com/ninuan/images/raw/main//images/image-20230720233741484.png" alt="image-20230720233741484" style="zoom:50%;" />
</li>
<li><p>下滑找到KV命名空间绑定，名称填<code>LINKS</code></p>
<img src="https://github.com/ninuan/images/raw/main//images/image-20230720233919422.png" alt="image-20230720233919422" style="zoom:50%;" />
</li>
<li><p>现在即可通过访问提供的网址进行访问<code>https://....workers.dev/dlj</code>，<code>dlj</code>就是你在第五部中添加的值，因为dev域名污染严重，有时候会进不去，我们可以绑定自己的域名，点击查看（如果没有域名，到这一步即可以使用）</p>
<img src="https://github.com/ninuan/images/raw/main//images/image-20230720234442039.png" alt="image-20230720234442039" style="zoom:50%;" />
</li>
<li><p>点击添加自定义域（域名需要在cloudflare存在解析，然后自己在域名前面添加二级域名即可）</p>
<img src="https://github.com/ninuan/images/raw/main//images/image-20230720234555680.png" alt="image-20230720234555680" style="zoom: 50%;" />
</li>
<li><p>通过你添加的域名加上第五步中你设置的值即可访问</p>
<img src="https://github.com/ninuan/images/raw/main//images/image-20230720234900048.png" alt="image-20230720234900048" style="zoom:50%;" /></li>
</ol>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>cloudflare</tag>
      </tags>
  </entry>
  <entry>
    <title>节点测速的高速方法</title>
    <url>/2023/07/23/%E8%8A%82%E7%82%B9%E6%B5%8B%E9%80%9F%E7%9A%84%E9%AB%98%E9%80%9F%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="高速优选节点快速的IP"><a href="#高速优选节点快速的IP" class="headerlink" title="高速优选节点快速的IP"></a>高速优选节点快速的IP</h2><ol>
<li><p>根据规则找到反代cloudflare的ip，网址<a href="https://fofa.info/">https://fofa.info</a></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 规则--根据自己想要的节点自己选择</span></span><br><span class="line">国内反代IP：server==&quot;cloudflare&quot; &amp;&amp; port==&quot;80&quot; &amp;&amp; header=&quot;Forbidden&quot; &amp;&amp; country==&quot;CN&quot;</span><br><span class="line">剔除CF：asn!=&quot;13335&quot; &amp;&amp; asn!=&quot;209242&quot;</span><br><span class="line">阿里云：server==&quot;cloudflare&quot; &amp;&amp; asn==&quot;45102&quot;</span><br><span class="line">甲骨文韩国：server==&quot;cloudflare&quot; &amp;&amp; asn==&quot;31898&quot; &amp;&amp; country==&quot;KR&quot;</span><br><span class="line">搬瓦工：server==&quot;cloudflare&quot; &amp;&amp; asn==&quot;25820&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>网站注册</p>
<p>临时邮箱：<a href="http://24mail.chacuo.net/">http://24mail.chacuo.net</a><br>（一个邮箱额度有限，可以用虚拟邮箱）</p>
</li>
<li><p>搜索完成后，点击下载</p>
<img src="https://github.com/ninuan/images/raw/main//images/image-20230723204214913.png" alt="image-20230723204214913" style="zoom:50%;" />
</li>
<li><p>下载到本地后，打开，找到对应的ip复制</p>
<img src="https://github.com/ninuan/images/raw/main//images/image-20230723204248143.png" alt="image-20230723204248143" style="zoom:50%;" />
</li>
<li><p>打开网址<a href="https://bulianglin.com/archives/cdn.html">https://bulianglin.com/archives/cdn.html</a> </p>
<p>原始节点需要用自己的节点分享出来，地址的话填写自己的伪装域名</p>
<img src="https://github.com/ninuan/images/raw/main//images/image-20230723210812062.png" alt="image-20230723210812062" style="zoom:50%;" />

<img src="https://github.com/ninuan/images/raw/main//images/image-20230723204500044.png" alt="image-20230723204500044" style="zoom:50%;" />
</li>
<li><p>下载测速工具<a href="https://short.ninuan.link/node">https://short.ninuan.link/node</a> ,解压后打开exe文件</p>
<img src="https://github.com/ninuan/images/raw/main//images/image-20230723210248913.png" alt="image-20230723210248913" style="zoom:50%;" />

<p>导入进去之后，<code>Ctrl + A</code>全选，右键测试延迟和速度（延迟内核和下载内核vless都选Xray，vmess内核选clash、Xray），测试完成之后复制节点导入到科学上网工具就行</p>
</li>
</ol>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>vpn</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机类试题</title>
    <url>/2023/08/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%A2%98%E7%9B%AE/</url>
    <content><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h3 id="头指针和头节点的区别？"><a href="#头指针和头节点的区别？" class="headerlink" title="头指针和头节点的区别？"></a>头指针和头节点的区别？</h3><p>以单链表为例，头指针就是指向链表第一个结点的指针，链表的第一个结点的地址可以通过链表的头指针找到，对单链表中任一元素的访问必须首先根据头指针找到第一个结点。</p>
<p>而头结点是一个附加结点，头结点的data域可以不存储任何信息，也可以存放特殊标志或表长，只要表存在就必须至少有一个头结点。头结点的存在可以优化单链表的增删操作，使得对于空表或者在非空表第一个结点之前插入不用作为特殊情况专门处理，而是使用通用方法。</p>
<h3 id="有一个循环队列Q，里面的编号是0到n-1，头尾指针分别是f，p，现在求Q中元素的个数？"><a href="#有一个循环队列Q，里面的编号是0到n-1，头尾指针分别是f，p，现在求Q中元素的个数？" class="headerlink" title="有一个循环队列Q，里面的编号是0到n-1，头尾指针分别是f，p，现在求Q中元素的个数？"></a>有一个循环队列Q，里面的编号是0到n-1，头尾指针分别是f，p，现在求Q中元素的个数？</h3><p><code>(p-f+n) % n</code></p>
<h3 id="循环队列如何判断是空还是满？"><a href="#循环队列如何判断是空还是满？" class="headerlink" title="循环队列如何判断是空还是满？"></a>循环队列如何判断是空还是满？</h3><p>队空：<code>front == rear</code>  队满：<code>front == (rear + 1) % m</code> </p>
<h3 id="哈希表的概念、构造方法、哈希有几种类型？哈希冲突的解决办法？"><a href="#哈希表的概念、构造方法、哈希有几种类型？哈希冲突的解决办法？" class="headerlink" title="哈希表的概念、构造方法、哈希有几种类型？哈希冲突的解决办法？"></a>哈希表的概念、构造方法、哈希有几种类型？哈希冲突的解决办法？</h3><ol>
<li><p>概念:哈希表通过哈希函数将键映射到表中一个位置来操作数据,以巧妙地将查找和插入的时间复杂度降低到O(1)</p>
</li>
<li><p>构造方法: 直接地址法; 数字分析法; 平方取中法; 随机数法; </p>
</li>
<li><p>哈希冲突的解决方法: </p>
<ol>
<li><p>开放地址法:线性探测、二次探测、伪随机探测等。</p>
</li>
<li><p>再哈希法:用其他哈希函数重新计算。</p>
</li>
<li><p>链地址法:将冲突的元素链起来,链接到同一个位置。</p>
</li>
<li><p>建立公共溢出区:将冲突元素放在其他位置。</p>
</li>
</ol>
</li>
</ol>
<h3 id="判断链表是否有环"><a href="#判断链表是否有环" class="headerlink" title="判断链表是否有环?"></a>判断链表是否有环?</h3><p>快慢指针: 从头开始设置两个指针，快指针每次走2步，慢指针每次走1步，如果快指针先碰到尾，则无环，否则两个指针之后一定会重合，则有环。</p>
<h3 id="平衡二叉树、二叉排序树、完全二叉树、二叉搜索树的区别及如何构造"><a href="#平衡二叉树、二叉排序树、完全二叉树、二叉搜索树的区别及如何构造" class="headerlink" title="平衡二叉树、二叉排序树、完全二叉树、二叉搜索树的区别及如何构造?"></a>平衡二叉树、二叉排序树、完全二叉树、二叉搜索树的区别及如何构造?</h3><ol>
<li><p>完全二叉树的每一个节点都与高度为k的满二叉树的1-n编号一一对应。</p>
</li>
<li><p>二叉搜索树和二叉排序树是一个东西。</p>
<ol>
<li><p>二叉排序树每一个节点都是用于排序的关键码，左子树所有节点关键码都小于根节点的关键码，右子树的所有关键码都大于根节点的关键码，其中，左右子树都是二叉树。对一棵二叉排序树进行中序遍历就可以得到关键码从小到大的排列。</p>
</li>
<li><p>二叉搜索树的构造方法主要执行插入操作，进行插入之前必须先检查是否该节点的关键码已经在树中存在，也就是要先查找，假如查找成功，不执行任何操作，假如搜索不成功，就在搜索停止的地方添加新元素。</p>
</li>
</ol>
</li>
<li><p>平衡二叉树是一种二叉搜索树，它的左右子树高度差的绝对值不超过1。构造一棵平衡二叉树仍然是通过插入节点的方式，每插入一个结点，都应该检查平衡因子，并通过旋转操作使之平衡化。</p>
</li>
</ol>
<h3 id="B树是什么-在数据库中有什么应用？（B数和B-树的区别）"><a href="#B树是什么-在数据库中有什么应用？（B数和B-树的区别）" class="headerlink" title="B树是什么?在数据库中有什么应用？（B数和B+树的区别）?"></a>B树是什么?在数据库中有什么应用？（B数和B+树的区别）?</h3><p>B树的一个结点可以装多个值，读取时，是把整个结点读到内存，然后在内存中，对结点的值进行处理，在内存中处理速度肯定比磁盘快。所以只要树的高度低，IO少，就能够提升查询效率，这是B树的好处之一。</p>
<p>B树的<strong>缺点</strong>是：不利于范围查找(区间查找)，如果要找 0~100的索引值，那么B树需要多次从根结点开始逐个查找。</p>
<p>B+树和B树最大的不同是：B+树内部有两种结点，一种是索引结点，一种是叶子结点。B+树的索引结点并不会保存记录，只用于索引，<strong>所有的数据都保存在B+树的叶子结点</strong>中。而<strong>B树则是所有结点都会保存数据</strong>。</p>
<p><strong>B+树的叶子结点都会被连成一条链表</strong>。叶子本身按索引值的大小从小到大进行排序。即这条链表是 从小到大的。因此可以直接通过遍历链表实现范围查找。</p>
<h3 id="红黑树原理是什么？建立过程？"><a href="#红黑树原理是什么？建立过程？" class="headerlink" title="红黑树原理是什么？建立过程？"></a>红黑树原理是什么？建立过程？</h3><p>​	红黑树（Red-Black Tree）是一种自平衡的二叉搜索树，它在插入和删除操作后通过一系列的旋转和颜色调整来保持树的平衡，从而保证了树的高度始终在一个相对较小的范围内，维持了搜索、插入和删除操作的平均时间复杂度为 O(log n)。</p>
<p>​	红黑树具有以下特性：</p>
<ol>
<li><strong>节点颜色：</strong> 每个节点都被赋予红色或黑色。</li>
<li><strong>根节点：</strong> 根节点是黑色的。</li>
<li><strong>叶子节点（空节点）：</strong> 所有叶子节点都是黑色的。</li>
<li><strong>红色节点的子节点：</strong> 红色节点的子节点必须是黑色的，这确保了没有两个相邻的红色节点。</li>
<li><strong>从任意节点到其每个叶子的简单路径都包含相同数目的黑色节点：</strong> 这个性质保证了树的平衡性，即从根到叶子的最长路径不会超过最短路径的两倍。</li>
</ol>
<p>​	红黑树的建立过程涉及插入和调整。以下是插入新节点时红黑树的建立过程：</p>
<ol>
<li><strong>插入节点：</strong> 将新节点插入到红黑树中，初始状态为红色。</li>
<li><strong>颜色调整：</strong> 检查插入节点的父节点和叔叔节点的颜色情况，进行以下几种情况的调整：<ul>
<li>如果父节点是黑色，无需进一步调整，树仍然满足红黑树性质。</li>
<li>如果父节点是红色，而叔叔节点也是红色，将父节点和叔叔节点变为黑色，将祖父节点变为红色，然后以祖父节点为当前节点进行递归调整，以保持红黑树性质。</li>
<li>如果父节点是红色，而叔叔节点是黑色或缺失，需要通过旋转来进行调整。</li>
</ul>
</li>
<li><strong>旋转操作：</strong> 旋转操作包括左旋和右旋，以恢复树的平衡性。旋转可以分为以下四种情况，分别对应着插入节点的父节点和祖父节点的位置关系以及插入节点的方向：<ul>
<li>LL旋转</li>
<li>RR旋转</li>
<li>LR旋转</li>
<li>RL旋转</li>
</ul>
</li>
</ol>
<p>​	通过递归调整和旋转操作，插入新节点后的红黑树会保持平衡性和红黑树性质。</p>
<h3 id="插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等排序算法的基本思想是什么？时间复杂度？是否稳定？给一个例子，问冒泡和快速排序在最坏的情况下比较几次？（排序必考）"><a href="#插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等排序算法的基本思想是什么？时间复杂度？是否稳定？给一个例子，问冒泡和快速排序在最坏的情况下比较几次？（排序必考）" class="headerlink" title="插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等排序算法的基本思想是什么？时间复杂度？是否稳定？给一个例子，问冒泡和快速排序在最坏的情况下比较几次？（排序必考）"></a>插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等排序算法的基本思想是什么？时间复杂度？是否稳定？给一个例子，问冒泡和快速排序在最坏的情况下比较几次？（排序必考）</h3><table>
<thead>
<tr>
<th>排序方法</th>
<th>时间复杂度（平均）</th>
<th>时间复杂度（最坏）</th>
<th>时间复杂度（最好）</th>
<th>空间复杂度</th>
<th>确定性</th>
</tr>
</thead>
<tbody><tr>
<td>插入排序</td>
<td>O(n^2^)</td>
<td>O(n^2^)</td>
<td>O(n)</td>
<td>O(1)</td>
<td>稳定</td>
</tr>
<tr>
<td>希尔排序</td>
<td>O(n^1.3^)</td>
<td>O(n^2^)</td>
<td>O(n)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td>选择排序</td>
<td>O(n^2^)</td>
<td>O(n^2^)</td>
<td>O(n^2^)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td>堆排序</td>
<td>O(nlog<del>n</del>n)</td>
<td>O(nlog<del>2</del>n)</td>
<td>O(nlog<del>2</del>n)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td>冒泡排序</td>
<td>O(n^2^)</td>
<td>O(n^2^)</td>
<td>O(n)</td>
<td>O(1)</td>
<td>稳定</td>
</tr>
<tr>
<td>快速排序</td>
<td>O(nlog<del>n</del>n)</td>
<td>O(n^2^)</td>
<td>O(nlog<del>n</del>n)</td>
<td>O(nlog<del>n</del>n)</td>
<td>不稳定</td>
</tr>
<tr>
<td>归并排序</td>
<td>O(nlog<del>n</del>n)</td>
<td>O(nlog<del>n</del>n)</td>
<td>O(nlog<del>n</del>n)</td>
<td>O(n)</td>
<td>稳定</td>
</tr>
<tr>
<td>桶排序</td>
<td>O(n+k)</td>
<td>O(n^2^)</td>
<td>O(n)</td>
<td>O(n+k)</td>
<td>稳定</td>
</tr>
<tr>
<td>基数排序</td>
<td>O(n*k)</td>
<td>O(n*k)</td>
<td>O(n*k)</td>
<td>O(n+k)</td>
<td>稳定</td>
</tr>
</tbody></table>
<h3 id="最小生成树和最短路径用什么算法来实现？（迪杰斯特拉、弗洛依德、普利姆、克鲁斯卡尔）算法的基本思想是什么？算法的时间复杂度？如何进行优化？"><a href="#最小生成树和最短路径用什么算法来实现？（迪杰斯特拉、弗洛依德、普利姆、克鲁斯卡尔）算法的基本思想是什么？算法的时间复杂度？如何进行优化？" class="headerlink" title="最小生成树和最短路径用什么算法来实现？（迪杰斯特拉、弗洛依德、普利姆、克鲁斯卡尔）算法的基本思想是什么？算法的时间复杂度？如何进行优化？"></a>最小生成树和最短路径用什么算法来实现？（迪杰斯特拉、弗洛依德、普利姆、克鲁斯卡尔）算法的基本思想是什么？算法的时间复杂度？如何进行优化？</h3><ol>
<li><p>最小生成树：普利姆，克鲁斯卡尔</p>
<p>最短路径：迪杰斯特拉（$O(n^2)$），弗洛伊德（$O(n^3)$）（单源负权边时是弗洛伊德算法）</p>
</li>
<li><p>算法的基本思想：</p>
<p>迪杰斯特拉，普利姆，克鲁斯卡尔都是贪心的思想</p>
<p>弗洛伊德是动态规划的思想</p>
</li>
<li><p>堆优化的迪杰斯特拉，克鲁斯卡尔，普利姆均为$O(nlogn)$</p>
</li>
</ol>
<h3 id="介绍一下字符串匹配算法：朴素的匹配算法和KMP算法。（如何实现要会用语言描述）"><a href="#介绍一下字符串匹配算法：朴素的匹配算法和KMP算法。（如何实现要会用语言描述）" class="headerlink" title="介绍一下字符串匹配算法：朴素的匹配算法和KMP算法。（如何实现要会用语言描述）"></a>介绍一下字符串匹配算法：朴素的匹配算法和KMP算法。（如何实现要会用语言描述）</h3><p>​	<strong>1. 朴素的匹配算法：</strong> 朴素的匹配算法也称为暴力匹配算法，它从文本串的每个位置开始，尝试将模式串与文本串的对应字符逐个比较，如果发现不匹配的字符，则将模式串向右移动一个位置，继续比较。这个过程会持续直到找到匹配或者文本串中没有足够的字符供比较。</p>
<p>​	<strong>实现步骤：</strong></p>
<ol>
<li>从文本串的第一个字符开始，遍历到文本串的倒数第 len(模式串) 个字符。</li>
<li>对于每个位置，将模式串与文本串当前位置开始的子串逐个字符比较，直到发现不匹配的字符或者完全匹配为止。</li>
<li>如果完全匹配，则找到了一个匹配的位置；如果不匹配，则将模式串向右移动一个位置，继续比较下一个子串。</li>
</ol>
<p>​	<strong>2. KMP算法：</strong> KMP算法通过利用模式串的部分匹配表（也称为失效函数或跳转表）来避免在文本串中不必要的比较，从而提高了匹配的效率。它在模式串与文本串匹配的过程中，根据已经匹配的字符，选择跳过一些比较，直接将模式串向右移动到正确的位置。</p>
<p>​	<strong>实现步骤：</strong></p>
<ol>
<li>构建模式串的部分匹配表，这个表记录了每个位置上前缀子串与后缀子串的最长公共前缀长度。</li>
<li>在文本串中，使用模式串的部分匹配表来指导匹配。当发生不匹配时，根据部分匹配表的值，将模式串向右移动一定的距离，而不是直接从下一个字符重新开始匹配。</li>
</ol>
<p>​	KMP算法的优势在于它避免了不必要的比较，使得算法的时间复杂度降低到O(n + m)，其中n是文本串的长度，m是模式串的长度。这使得KMP算法在大规模文本中查找模式更加高效。</p>
<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h3 id="OSI和TCP-IP-模型各个层之间的协议和功能"><a href="#OSI和TCP-IP-模型各个层之间的协议和功能" class="headerlink" title="OSI和TCP&#x2F;IP 模型各个层之间的协议和功能"></a>OSI和TCP&#x2F;IP 模型各个层之间的协议和功能</h3><img src="https://github.com/ninuan/images/raw/main//images/image-20230816164258354.png" alt="image-20230816164258354" style="zoom: 67%;" />

<h3 id="简述一下层次路由的原理（叙述一下与自治系统相关的内部网关协议和外部网关协议）单工、半双工、全双工通信？"><a href="#简述一下层次路由的原理（叙述一下与自治系统相关的内部网关协议和外部网关协议）单工、半双工、全双工通信？" class="headerlink" title="简述一下层次路由的原理（叙述一下与自治系统相关的内部网关协议和外部网关协议）单工、半双工、全双工通信？"></a>简述一下层次路由的原理（叙述一下与自治系统相关的内部网关协议和外部网关协议）单工、半双工、全双工通信？</h3><p>​		层次路由的原理是将路由分成不同的层级,以提高路由效率和可扩展性。</p>
<p>​		自治系统内部使用内部网关协议(IGP),如<strong>RIP、OSPF</strong>、IS-IS等,用于在自治系统内部交换路由信息,计算最短路径。</p>
<p>​		自治系统之间使用外部网关协议(EGP),如<strong>BGP</strong>,用于在不同的AS之间交换路由可达信息,传递路由更新。BGP不计算最短路径,仅传递可达性信息。</p>
<p>​		单工通信:数据只能单向传输,如无线广播。</p>
<p>​		半双工通信:数据可以双向传输,但每个时刻只能单向传输,如对讲机。</p>
<p>​		全双工通信:数据可以同时双向传输,如电话通话。</p>
<p>​		综上所述,层次路由通过内部网关协议和外部网关协议分级交换路由信息,提高了路由可扩展性。通信模式决定了数据传输的方向性,单工只能单向,半双工必须轮流,全双工可以双向同时进行。</p>
<h3 id="协议三要素"><a href="#协议三要素" class="headerlink" title="协议三要素"></a>协议三要素</h3><p>​		语法，语义，时序</p>
<h3 id="香农公式？信道容量含义？带宽增加，信道容量怎么变？香农公式的前提条件？"><a href="#香农公式？信道容量含义？带宽增加，信道容量怎么变？香农公式的前提条件？" class="headerlink" title="香农公式？信道容量含义？带宽增加，信道容量怎么变？香农公式的前提条件？"></a>香农公式？信道容量含义？带宽增加，信道容量怎么变？香农公式的前提条件？</h3><p>​	$C &#x3D; B*log_2(1 + S&#x2F;N)$</p>
<p>​	信道容量表示在给定带宽下，在一定信噪比条件下，可以无误传输的最大比特率；带宽增加，在相同信噪比的情况下，信道容量C会增加。</p>
<p>​	香农公式的前提条件：系统中只存在加性高斯白噪声，而不存在其他干扰。</p>
<h3 id="CSMA-CD-协议"><a href="#CSMA-CD-协议" class="headerlink" title="CSMA&#x2F;CD 协议"></a>CSMA&#x2F;CD 协议</h3><p>​	先听后发，边发边听，冲突停发，随机延迟后重发（截断二进制指数退避算法）</p>
<p>​	载波侦听多路访问／碰撞检测(Carrier Sense Multiple Access with Collision Detection, CSMA&#x2F;CD) </p>
<p>协议是CSMA 协议的改进方案。” 载波帧听” 就是发送前先侦听，即每个站在发送数据之前先要检测 一下总线上是否有其他站点正在发送数据，若有则暂时不发送数据，等待信道变为空闲时再发送。” 碰撞检测” 就是边发送边侦听，即适配器边发送数据边检测信道上信号电压的变化情况，以 便判断自己在发送数据时其他站点是否也在发送数据。工作流程可简单概括为“先听后发，边听边 发（区别于CSMA 协议），冲突停发，随机重发”。 </p>
<ol>
<li><p>适配器从其父结点获得一个网络层数据报，准备一个以太网帧，并把该帧放到适配器缓冲区中。 </p>
</li>
<li><p>如果适配器侦听到信道空闲，那么它开始传输该帧。如果适配器侦听到信道忙，那么它将等待直至侦听到没有信号能量，然后开始传输该帧。</p>
</li>
</ol>
<ol start="3">
<li>在传输过程中，适配器检测来自其他适配器的信号能量。如果这个适配器传输了整帧，而没 有检测到来自其他适配器的信号能量，那么这个适配器完成该帧的传输。否则，适配器就须停止传输它的帧，取而代之传输一个48 比特的拥塞信号。</li>
</ol>
<ol start="4">
<li>在中止（即传输拥塞信号）后，适配器采用截断二进制指数退避算法等待一段随机时间后返回到步骤2。</li>
</ol>
<h3 id="TCP-和-UDP协议"><a href="#TCP-和-UDP协议" class="headerlink" title="TCP 和 UDP协议"></a>TCP 和 UDP协议</h3><ol>
<li><p>相同点：二者都是工作在传输层，双方的通信都要开放端口</p>
</li>
<li><p>不同点：</p>
<ol>
<li><p>TCP是可靠传输，UDP是不可靠传输</p>
</li>
<li><p>TCP是基于连接的协议，在正式收发数据前，必须和对方建立可靠的连接。  </p>
<p>UDP是和TCP相对应的协议，它是面向非连接的协议，它不与对方建立连接，而是直接把数据包发送出去</p>
</li>
<li><p>TCP是一种可靠的通信服务，负载相对而言比较大，TCP采用套接字（socket）或者端口（port）来建立通信。   </p>
<p>UDP是一种不可靠的网络服务，负载比较小。</p>
</li>
<li><p>TCP和UDP结构不同，TCP包括序号、确认信号、数据偏移、控制标志（通常说的URG、ACK、PSH、RST、SYN、FIN）、窗口、校验和、紧急指针、选项等信息。   </p>
<p>UDP包含长度和校验和信息。</p>
</li>
<li><p>TCP提供超时重发，丢弃重复数据，检验数据，流量控制等功能，保证数据能从一端传到另一端。   </p>
<p>UDP不提供可靠性，它只是把应用程序传给IP层的数据报发送出去，但是并不能保证它们能到达目的地。</p>
</li>
<li><p>TCP在发送数据包前在通信双方有一个三次握手机制，确保双方准备好，在传输数据包期间，TCP会根据链路中数据流量的大小来调节传送的速率，传输时如果发现有丢包，会有严格的重传机制，故而传输速度很慢。  </p>
<p>UDP在传输数据报前不用在客户和服务器之间建立一个连接，且没有超时重发等机制，故而传输速度很快。</p>
</li>
<li><p>TCP支持全双工和并发的TCP连接，提供确认、重传与拥塞控制。 </p>
<p>   UDP适用于哪些系统对性能的要求高于数据完整性的要求，需要“简短快捷”的数据交换、需要多播和广播的应用环境。</p>
</li>
</ol>
</li>
<li><p>TCP的三次握手：<a href="https://blog.csdn.net/guoweimelon/article/details/50878730">https://blog.csdn.net/guoweimelon/article/details/50878730</a></p>
<p>TCP的四次挥手：<a href="https://blog.csdn.net/guoweimelon/article/details/50879302">https://blog.csdn.net/guoweimelon/article/details/50879302</a></p>
<p>如果二次握手：</p>
<p>先假如出现了一种异常情况，即A发出的第一个连接请求报文段因为在某些网络节点上滞留了。由于超时重传，于是A又向B发起请求并成功建立了连接，在传输完数据之后，AB同之间释放了连接。</p>
<p>而在A和B已经释放连接之后，那个在网络上滞留的报文段又达到了B。这时候，B接收到报文以为是A发起的新的一次建立连接的请求，于是就向A发出确认建立连接报文段。而A此时并没有发起建立连接的请求，于是不予理睬。但是B以为新的连接已经建立，一直等待A发送数据，于是B的许多资源就浪费了。</p>
</li>
<li><p>TCP协议保证数据传输可靠性的方式主要有：校验和；序列号；确认应答；超时重传；连接管理；流量控制；拥塞控制；</p>
<p><a href="https://blog.csdn.net/liuchenxia8/article/details/80428157?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164024563516780274155503%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164024563516780274155503&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-80428157.pc_search_insert_es_download&utm_term=TCP%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93&spm=1018.2226.3001.4187">TCP可靠传输</a></p>
</li>
<li><p>TCP拥塞控制中，<a href="https://blog.csdn.net/sinat_21112393/article/details/50810053?ops_request_misc=&request_id=&biz_id=102&utm_term=%E5%9C%A8TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E4%B8%AD%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E6%85%A2%E5%BC%80%E5%A7%8B%E3%80%81%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D%E3%80%81%E5%BF%AB%E9%87%8D%E4%BC%A0%E5%92%8C%E5%BF%AB%E6%81%A2%E5%A4%8D%E7%AE%97&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-50810053.pc_search_result_control_group&spm=1018.2226.3001.4187">慢开始，拥塞避免，快重传和快恢复算法</a></p>
</li>
</ol>
<h3 id="流量控制和拥塞是什么关系？"><a href="#流量控制和拥塞是什么关系？" class="headerlink" title="流量控制和拥塞是什么关系？"></a>流量控制和拥塞是什么关系？</h3><p>​	流量控制解决的是发送方和接收方速率不匹配的问题；拥塞控制解决的是避免网络资源被耗尽的问题。流量控制是通过滑动窗口来实现的；拥塞控制是通过拥塞窗口来实现的。</p>
<p>​	拥塞控制是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况；常用的方法就是：慢开始、拥塞避免、快重传、快恢复。 </p>
<p>​	流量控制是作用于接收者的，它是控制发送者的发送速度从而使接收者来得及接收，防止分组丢失的。</p>
<h3 id="两个服务器之间网络已经联通，却收不到彼此的UDP报文原因"><a href="#两个服务器之间网络已经联通，却收不到彼此的UDP报文原因" class="headerlink" title="两个服务器之间网络已经联通，却收不到彼此的UDP报文原因"></a>两个服务器之间网络已经联通，却收不到彼此的UDP报文原因</h3><p>​	可能的原因很多，比如设置了acl（访问控制列表），禁用了某些端口，网络拥塞，丢包等</p>
<p>​	主要丢包原因</p>
<ol>
<li><p>接收端处理时间过长导致丢包</p>
</li>
<li><p>发送的包巨大丢包</p>
</li>
<li><p>发送的包较大，超过接受者缓存导致丢包</p>
</li>
<li><p>发送的包频率太快。</p>
</li>
<li><p>局域网内不丢包，公网上丢包</p>
</li>
</ol>
<h3 id="网卡是什么？功能？"><a href="#网卡是什么？功能？" class="headerlink" title="网卡是什么？功能？"></a>网卡是什么？功能？</h3><p>​	网卡是工作在<strong>链路层</strong>的网络组件，是局域网中连接计算机和传输介质的接口，不仅能实现与局域网传输介质之间的物理连接和电信号匹配，还涉及<strong>帧的发送与接收、帧的封装与拆封、介质访问控制、数据的编码与解码以及数据缓存的功能</strong>等。</p>
<p>​	网卡的作用：</p>
<p>​	网络是通过<strong>模拟信号将信息转化为电流传播</strong>的，网卡在这里面就充当了一个解码器的作用，将电信号重新转换文文字图像等就是网卡的责任。网卡的其他功能还有监控上传及下载流量，控制网速稳定的作用，它就相当于电脑的港口，所有信息上传到网络之前都要先到网卡这里走一遭。</p>
<p>​	每台电脑都有网卡，没有网卡无法上网。</p>
<h3 id="简述下DNS域名解析的过程"><a href="#简述下DNS域名解析的过程" class="headerlink" title="简述下DNS域名解析的过程"></a>简述下DNS域名解析的过程</h3><ol>
<li><p>当客户机提出查询请求时，首先在本地计算机的缓存中查找。如果在本地无法获得查询信息，则将查询请求发给DNS服务器。</p>
</li>
<li><p>首先客户机将域名查询请求发送到本地DNS服务器,当本地DNS服务器接到查询后，首先在该服务器管理的区域的记录中查找，如果找到该记录，则利用此记录进行解析；如果没有区域信息可以满足查询要求，服务器在本地的缓存中查找。</p>
</li>
<li><p>如果本地服务器不能在本地找到客户机查询的信息，将客户机请求发送到根域名DNS服务器。</p>
</li>
<li><p>根域名服务器负责解析客户机请求的根域部分，它将包含下一级域名信息的DNS服务器地址返回给客户机的DNS服务器地址。</p>
</li>
<li><p>客户机的DNS服务器利用根域名服务器解析的地址访问下一级DNS服务器，得到再下一级域我的DNS服务器地址。</p>
</li>
<li><p>按照上述递归方法逐级接近查询目标，最后在有目标域名的DNS服务器上找到相应IP地址信息。</p>
</li>
<li><p>客户机的本地DNS服务器将递归查询结果返回客户机。</p>
</li>
<li><p>客户机利用从本地DNS服务器查询得到的IP访问目标主机，就完成了一个解析过程。</p>
</li>
</ol>
<h3 id="点击网页一次HTTP请求过程"><a href="#点击网页一次HTTP请求过程" class="headerlink" title="点击网页一次HTTP请求过程?"></a>点击网页一次HTTP请求过程?</h3><ol>
<li>域名解析</li>
<li>将消息从PC传到服务器,使用IP、ARP协议和OSPF协议</li>
<li>发起TCP的3次握手</li>
<li>建立TCP连接后发起http请求</li>
<li>服务器响应http请求</li>
<li>浏览器解析html代码，并请求html代码中的资源</li>
<li>断开TCP连接</li>
<li>浏览器对网页进行渲染呈现给用户</li>
</ol>
<h3 id="简述一下Cookie-和-Session的区别"><a href="#简述一下Cookie-和-Session的区别" class="headerlink" title="简述一下Cookie 和 Session的区别"></a>简述一下Cookie 和 Session的区别</h3><ol>
<li><p>数据存放位置不同：cookie存储在客户的浏览器上，session存储在服务器上</p>
</li>
<li><p>安全程度不同：cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗</p>
</li>
<li><p>性能使用程度不同：session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能,考虑到减轻服务器性能方面，应当使用cookie</p>
</li>
<li><p>数据存储大小不同：单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie，而session则存储与服务端，浏览器对其没有限制</p>
</li>
<li><p>会话机制不同：</p>
<p>session会话机制：session会话机制是一种服务器端机制，它使用类似于哈希表（可能还有哈希表）的结构来保存信息。</p>
<p>cookies会话机制：cookie是服务器存储在本地计算机上的小块文本，并随每个请求发送到同一服务器。 Web服务器使用HTTP标头将cookie发送到客户端。在客户端终端，浏览器解析cookie并将其保存为本地文件，该文件自动将来自同一服务器的任何请求绑定到这些cookie</p>
</li>
</ol>
<p><a href="https://www.cnblogs.com/zyf-zhaoyafei/p/4716297.html">计算机网络之面试常考</a></p>
<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h3 id="操作系统的特点？功能？"><a href="#操作系统的特点？功能？" class="headerlink" title="操作系统的特点？功能？"></a>操作系统的特点？功能？</h3><p>​	操作系统特点：操作系统的四个基本特征是并发,共享,异步,虚拟。而每个操作系统又有其独特的特征，如我们常用的linux系统有开放性;多用户多任务;设备的独立性;强大的网络功能和网络可靠性等特点。</p>
<p>​	操作系统的功能：管理计算机系统的全部软、硬件资源 , 合理组织计算机的工作流程 , 以达到充分发挥计算机资源的效率 , 为用户提供友好界面</p>
<h3 id="中断和系统调用的区别"><a href="#中断和系统调用的区别" class="headerlink" title="中断和系统调用的区别"></a>中断和系统调用的区别</h3><p>​	中断分两种，硬中断和软中断；硬中断是实实在在的硬件发出的中断，cpu检测到发生中断后，保护现场，查找中断向量地址，执行中断服务程序，之后，重新选择进程进行调度。软中断是由指令执行过程中发出的中断，但是并没有中断向量表，而是有对应的散转表，查找对应的中断号，转中断服务程序，之后的和硬中断相同。</p>
<pre><code> 系统调用是软中断的一种。
</code></pre>
<h3 id="进程、线程的概念以及区别？进程间的通信方式？"><a href="#进程、线程的概念以及区别？进程间的通信方式？" class="headerlink" title="进程、线程的概念以及区别？进程间的通信方式？"></a>进程、线程的概念以及区别？进程间的通信方式？</h3><ol>
<li>​	区别：<ol>
<li>进程是具有一定功能的程序，是系统进行资源分配调度的一个独立单位</li>
<li>线程是进程的一个实体，是CPU调度分配的基本单位，线程之间基本上不拥有系统资源</li>
<li>一个程序至少有一个进程，一个进程至少有一个线程，资源分配给进程，同一个进程下所有线程共享该进程的资源</li>
</ol>
</li>
<li>进程间的通信方式：<a href="https://blog.csdn.net/zhaohong_bo/article/details/89552188">https://blog.csdn.net/zhaohong_bo/article/details/89552188</a></li>
<li>线程哪些资源共享？哪些资源不共享？<ol>
<li>共享：堆、全局变量、静态变量、文件等共有资源</li>
<li>独享：栈、寄存器</li>
</ol>
</li>
</ol>
<h3 id="进程有哪几种状态，状态之间的转换、进程调度策略？"><a href="#进程有哪几种状态，状态之间的转换、进程调度策略？" class="headerlink" title="进程有哪几种状态，状态之间的转换、进程调度策略？"></a>进程有哪几种状态，状态之间的转换、进程调度策略？</h3><ol>
<li><p>四种状态：就绪，运行，阻塞，终止</p>
<img src="https://github.com/ninuan/images/raw/main//images/image-20230817171832031.png" alt="image-20230817171832031" style="zoom:67%;" />
</li>
<li><p>进程调度策略</p>
<ol>
<li><p>先来先服务调度算法</p>
</li>
<li><p>短作业优先调度算法</p>
</li>
<li><p>高优先权优先调度算法</p>
<ol>
<li>非抢占式优先权算法</li>
<li>抢占式优先权调度算法</li>
</ol>
</li>
<li><p>高响应比优先调度算法</p>
<p>$R_p &#x3D; \frac{等待时间+要求服务时间}{要求服务时间} &#x3D; \frac{响应时间}{要求服务时间}$</p>
</li>
<li><p>时间片轮转法</p>
</li>
<li><p>多级反馈队列调度算法</p>
<ol>
<li>应设置多个就绪队列，并为各个队列赋予不同的优先级</li>
<li>当一个新进程进入内存后，首先将它放入第一队列的末尾，按FCFS原则排队等待调度</li>
<li>仅当第一队列空闲时，调度程序才调度第二序列中的进程运行</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="什么是死锁？死锁产生的四个必要条件？如何预防死锁？"><a href="#什么是死锁？死锁产生的四个必要条件？如何预防死锁？" class="headerlink" title="什么是死锁？死锁产生的四个必要条件？如何预防死锁？"></a>什么是死锁？死锁产生的四个必要条件？如何预防死锁？</h3><ol>
<li>死锁：是指多个进程因竞争资源而造成的一种僵局(互相等待)，若无外力作用，这些进程都将无法向前推进</li>
<li>四个必要条件：<ol>
<li>互斥条件</li>
<li>请求和保持条件</li>
<li>不剥夺条件</li>
<li>环路等待条件</li>
</ol>
</li>
<li>产生死锁的原因：<ol>
<li>竞争不可抢占型资源</li>
<li>竞争可消耗型资源（硬件中断、信号、消息、缓冲区内的消息等）</li>
<li>进程推进顺序不当</li>
</ol>
</li>
<li>如何预防死锁：<ol>
<li>资源一次性分配（一次性分配所有资源，这样就不会再有请求了，破坏了请求条件）</li>
<li>允许程序获得运行初期条件的所有资源后开始运行，过程中逐步释放给自己的已用完的资源，然后再请求新的资源（破坏请求保持条件）</li>
<li>可剥夺资源：即当某进程获得了部分资源，但得不到其他资源，则释放已占有的资源（破坏不可剥夺条件）</li>
<li>资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请资源，释放则相反（破坏环路等待条件）</li>
</ol>
</li>
</ol>
<h3 id="哲学家进餐有哪些实现方式？"><a href="#哲学家进餐有哪些实现方式？" class="headerlink" title="哲学家进餐有哪些实现方式？"></a>哲学家进餐有哪些实现方式？</h3><ol>
<li>核心是保证至少有一位哲学家能拿到两只筷子就餐后释放筷子：<ol>
<li>最多只允许n-1个哲学家拿起筷子就餐</li>
<li>资源分级算法，奇数号哲学家先拿左边的筷子，偶数号哲学家先拿右边的筷子</li>
<li>设立规则，当一位哲学家拿起一只筷子时，另一个筷子无法得到，则放下刚刚拿起的筷子</li>
<li>服务生算法，一次只允许一名哲学家进餐，等到这名哲学家就餐完毕后才允许其他哲学家进餐</li>
</ol>
</li>
</ol>
<h3 id="简述下银行家算法"><a href="#简述下银行家算法" class="headerlink" title="简述下银行家算法"></a>简述下银行家算法</h3><p>银行家算法是一种最有代表性的避免死锁的算法。在避免死锁方法中允许进程动态地申请资源，但系统在进行资源分配之前，应先计算此次分配资源的安全性，若分配不会导致系统进入不安全状态，则分配，否则等待。为实现银行家算法，系统必须设置若干数据结构。</p>
<p>银行家算法中的数据结构</p>
<p>为了实现银行家算法，必须设置以下四个数据结构:</p>
<ol>
<li><p>可利用资源向量Available:其初始值是系统中所配置的该类全部可用资源的数目。</p>
</li>
<li><p>最大需求矩阵Max:它定义了系统中n个进程中的每一个进程对m类资源的最大需求。</p>
</li>
<li><p>分配矩阵Allocation:它定义了系统中每一类资源当前已分配给每一个进程的资源数。</p>
</li>
<li><p>需求矩阵Need：用一表示每一个进程尚需的各类资源数。</p>
</li>
</ol>
<h3 id="分页的作用，好处？和分段有什么区别？"><a href="#分页的作用，好处？和分段有什么区别？" class="headerlink" title="分页的作用，好处？和分段有什么区别？"></a>分页的作用，好处？和分段有什么区别？</h3><ol>
<li>页是信息的物理单位，分页是为了实现非连续分配，以便解决内存碎片问题，或者说分页是由于系统管理的需要。段是信息的逻辑单位，它含有一组意义相对完整的信息，分段的目的是为了更好的实现共享，满足用户的需求。</li>
<li>页的大小固定且有系统确定，将逻辑地址划分为页号和业内地址是有机器硬件实现的，而段的长度却不固定，决定于用户所编写的程序，通常由编译程序在对源程序进行编译时根据信息的性质来划分</li>
<li>分页的作业地址空间是一维的；分段的地址空间是二维的</li>
</ol>
<h3 id="什么是虚拟内存？什么是共享内存？"><a href="#什么是虚拟内存？什么是共享内存？" class="headerlink" title="什么是虚拟内存？什么是共享内存？"></a>什么是虚拟内存？什么是共享内存？</h3><ol>
<li>虚拟内存是计算机系统内存管理的一种技术，它使得应用程序认为它拥有连续可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。与没有使用虚拟内存技术的系统相比，使用这种技术的系统使得大型程序的编写变得更容易，对真正的物理内存（例如RAM）的使用也更有效率</li>
<li>共享内存是最快速的进程间通信机制，操作系统在几个进程的地址空间上映射一段内存，然后这几个进程可以在不需要调用操作系统函数的情况下在那段内存上进行读&#x2F;写操作</li>
</ol>
<h3 id="页面置换算法？"><a href="#页面置换算法？" class="headerlink" title="页面置换算法？"></a>页面置换算法？</h3><ol>
<li>最佳置换算法（OPT）：每次选择淘汰的页面将是以后永不使用，或者在最长时间内不再被访问的页面，这样可以保证最低的缺页率</li>
<li>先进先出置换算法（FIFO）：每次选择淘汰的页面是最早进入内存的页面</li>
<li>最近最久未使用置换算法：每次淘汰的页面是最近最久未使用的页面</li>
<li>时钟置换算法：为每个页面设置一个访问位，再将内存中的页面都通过链接指针链接成一个循环队列。当某个页面被访问时，其访问位置设置为1，当需要淘汰一个页面时，只需检查页的访问位。如果是0，就选择该页换出；如果是1，暂不换出，将访问位改为0，继续检查下一个页面，若第一轮 扫描中所有的页面都是1，则将这些页面的访问位一次置为0后，再进行第二轮扫描（第二轮扫描中一定会有访问位为0的页面，因此简单的CLOCK算法选择一个淘汰页面最多会经过两轮扫描）</li>
<li>改进型时钟置换算法：<a href="https://www.jianshu.com/p/18285ecffbfb">https://www.jianshu.com/p/18285ecffbfb</a></li>
</ol>
<h3 id="磁盘调度算法以及磁盘空间存储管理？"><a href="#磁盘调度算法以及磁盘空间存储管理？" class="headerlink" title="磁盘调度算法以及磁盘空间存储管理？"></a>磁盘调度算法以及磁盘空间存储管理？</h3><p><a href="https://blog.csdn.net/lishanleilixin/article/details/89709194">https://blog.csdn.net/lishanleilixin/article/details/89709194</a></p>
<h1 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h1><h3 id="冯诺依曼机的体系结构"><a href="#冯诺依曼机的体系结构" class="headerlink" title="冯诺依曼机的体系结构"></a>冯诺依曼机的体系结构</h3><img src="https://github.com/ninuan/images/raw/main//images/image-20230818142451335.png" alt="image-20230818142451335" style="zoom: 67%;" />

<p>​	主要由五大部件组成：</p>
<ol>
<li>存储器用来存放数据和程序</li>
<li>运算器主要运行算数运算和逻辑运算，并将中间结果暂存到运算器中</li>
<li>控制器主要用来控制和指挥程序和数据的输入运行，以及处理运算结果</li>
<li>输入设备用来将人们熟悉的信息形式转换为机器能够识别的信息形式，常见的由键盘，鼠标等</li>
<li>输出设备可以将机器运算结果转换为人们熟悉的信息形式，如打印机输出，显示器输出等</li>
</ol>
<h3 id="衡量计算机性能指标"><a href="#衡量计算机性能指标" class="headerlink" title="衡量计算机性能指标"></a>衡量计算机性能指标</h3><ol>
<li><p>吞吐量：表征一台计算机在某一时间间隔内能够处理的信息量，单位是字节&#x2F;秒</p>
</li>
<li><p>响应时间：表征从输入有效到系统产生响应之间的时间度量，用时间单位来度量</p>
</li>
<li><p>利用率：表示在给定的时间间隔内，系统被实际使用的时间所占的比例，一般用百分比表示</p>
</li>
<li><p>处理机字长：指处理机运算器中一次能够完成二进制运算的位数，字长越长，表示计算的精度越高</p>
</li>
<li><p>总线宽度：一般指CPU中运算器与存储器之间进行互连的内部总线二进制位数</p>
</li>
<li><p>存储器容量：存储器中所有存储单元的总数目，通常用KB等表示</p>
</li>
<li><p>存储器带宽：存储器的速度指标，单位时间内从存储器读出的二进制数信息量，一般用字节数&#x2F;秒表示</p>
</li>
<li><p>主频&#x2F;时间周期：CPU的工作节拍受主时钟控制，主时钟不断产生固定频率的时钟，主时钟的频率（f）叫CPU的主频。度量单位是MHz、GHz。   主频的倒数称为CPU时钟周期（T），即T&#x3D;1&#x2F;f，度量单位是微秒、纳秒。</p>
</li>
<li><p>CPU执行时间：表示CPU执行一段程序所占用的CPU时间，可用下式计算：   CPU执行时间 ＝   CPU时钟周期数 × CPU时钟周期长 CPI：表示每条指令周期数，即执行一条指令所需的平均时钟周期数。  用下式计算：</p>
<p>MIPS:每秒百万条数据。MIPS是单位时间内的执行指令数，所以MIPS值越高说明机器速度越快。 MFLOPS是基于操作而非指令的，只能用来衡量机器浮点操作的性能，而不能体现机器的整体性能</p>
</li>
</ol>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Learn</tag>
      </tags>
  </entry>
</search>
